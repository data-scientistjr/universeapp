{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React, { useEffect, useLayoutEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport debounce from 'lodash.debounce';\nimport throttle from 'lodash.throttle';\nimport { logChatPromiseExecution } from 'stream-chat';\nimport { nanoid } from 'nanoid';\nimport clsx from 'clsx';\nimport { channelReducer, initialState } from './channelState';\nimport { commonEmoji, defaultMinimalEmojis, emojiSetDef } from './emojiData';\nimport { useCreateChannelStateContext } from './hooks/useCreateChannelStateContext';\nimport { useCreateTypingContext } from './hooks/useCreateTypingContext';\nimport { useEditMessageHandler } from './hooks/useEditMessageHandler';\nimport { useIsMounted } from './hooks/useIsMounted';\nimport { useMentionsHandlers } from './hooks/useMentionsHandlers';\nimport { Attachment as DefaultAttachment } from '../Attachment/Attachment';\nimport { LoadingErrorIndicator as DefaultLoadingErrorIndicator } from '../Loading';\nimport { LoadingChannel as DefaultLoadingIndicator } from './LoadingChannel';\nimport { MessageSimple } from '../Message/MessageSimple';\nimport { DropzoneProvider } from '../MessageInput/DropzoneProvider';\nimport { ChannelActionProvider } from '../../context/ChannelActionContext';\nimport { ChannelStateProvider } from '../../context/ChannelStateContext';\nimport { ComponentProvider } from '../../context/ComponentContext';\nimport { useChatContext } from '../../context/ChatContext';\nimport { EmojiProvider } from '../../context/EmojiContext';\nimport { useTranslationContext } from '../../context/TranslationContext';\nimport { TypingProvider } from '../../context/TypingContext';\nimport { DEFAULT_INITIAL_CHANNEL_PAGE_SIZE, DEFAULT_NEXT_CHANNEL_PAGE_SIZE, DEFAULT_THREAD_PAGE_SIZE } from '../../constants/limits';\nimport { hasMoreMessagesProbably, hasNotMoreMessages } from '../MessageList/utils';\nimport defaultEmojiData from '../../stream-emoji.json';\nimport { makeAddNotifications } from './utils';\nimport { useChannelContainerClasses } from './hooks/useChannelContainerClasses';\nimport { getImageAttachmentConfiguration, getVideoAttachmentConfiguration } from '../Attachment/attachment-sizing';\nvar UnMemoizedChannel = function UnMemoizedChannel(props) {\n  var propsChannel = props.channel,\n    _a = props.EmptyPlaceholder,\n    EmptyPlaceholder = _a === void 0 ? null : _a,\n    LoadingErrorIndicator = props.LoadingErrorIndicator,\n    _b = props.LoadingIndicator,\n    LoadingIndicator = _b === void 0 ? DefaultLoadingIndicator : _b;\n  var _c = useChatContext('Channel'),\n    contextChannel = _c.channel,\n    channelsQueryState = _c.channelsQueryState,\n    customClasses = _c.customClasses,\n    theme = _c.theme;\n  var _d = useChannelContainerClasses({\n      customClasses: customClasses\n    }),\n    channelClass = _d.channelClass,\n    chatClass = _d.chatClass;\n  var channel = propsChannel || contextChannel;\n  var className = clsx(chatClass, theme, channelClass);\n  if (channelsQueryState.queryInProgress === 'reload' && LoadingIndicator) {\n    return React.createElement(\"div\", {\n      className: className\n    }, React.createElement(LoadingIndicator, null));\n  }\n  if (channelsQueryState.error && LoadingErrorIndicator) {\n    return React.createElement(\"div\", {\n      className: className\n    }, React.createElement(LoadingErrorIndicator, {\n      error: channelsQueryState.error\n    }));\n  }\n  if (!(channel === null || channel === void 0 ? void 0 : channel.cid)) {\n    return React.createElement(\"div\", {\n      className: className\n    }, EmptyPlaceholder);\n  }\n  // @ts-ignore\n  return React.createElement(ChannelInner, __assign({}, props, {\n    channel: channel,\n    key: channel.cid\n  }));\n};\nvar ChannelInner = function ChannelInner(props) {\n  var _a;\n  var acceptedFiles = props.acceptedFiles,\n    activeUnreadHandler = props.activeUnreadHandler,\n    channel = props.channel,\n    children = props.children,\n    doMarkReadRequest = props.doMarkReadRequest,\n    doSendMessageRequest = props.doSendMessageRequest,\n    doUpdateMessageRequest = props.doUpdateMessageRequest,\n    _b = props.dragAndDropWindow,\n    dragAndDropWindow = _b === void 0 ? false : _b,\n    _c = props.emojiData,\n    emojiData = _c === void 0 ? defaultEmojiData : _c,\n    _d = props.LoadingErrorIndicator,\n    LoadingErrorIndicator = _d === void 0 ? DefaultLoadingErrorIndicator : _d,\n    _e = props.LoadingIndicator,\n    LoadingIndicator = _e === void 0 ? DefaultLoadingIndicator : _e,\n    maxNumberOfFiles = props.maxNumberOfFiles,\n    _f = props.multipleUploads,\n    multipleUploads = _f === void 0 ? true : _f,\n    onMentionsClick = props.onMentionsClick,\n    onMentionsHover = props.onMentionsHover,\n    _g = props.optionalMessageInputProps,\n    optionalMessageInputProps = _g === void 0 ? {} : _g,\n    skipMessageDataMemoization = props.skipMessageDataMemoization;\n  var _h = useChatContext('Channel'),\n    client = _h.client,\n    customClasses = _h.customClasses,\n    latestMessageDatesByChannels = _h.latestMessageDatesByChannels,\n    mutes = _h.mutes,\n    theme = _h.theme;\n  var t = useTranslationContext('Channel').t;\n  var _j = useChannelContainerClasses({\n      customClasses: customClasses\n    }),\n    channelClass = _j.channelClass,\n    chatClass = _j.chatClass,\n    chatContainerClass = _j.chatContainerClass,\n    windowsEmojiClass = _j.windowsEmojiClass;\n  var _k = useState(channel.getConfig()),\n    channelConfig = _k[0],\n    setChannelConfig = _k[1];\n  var _l = useState([]),\n    notifications = _l[0],\n    setNotifications = _l[1];\n  var _m = useState(),\n    quotedMessage = _m[0],\n    setQuotedMessage = _m[1];\n  var notificationTimeouts = [];\n  var _o = useReducer(channelReducer, __assign(__assign({}, initialState), {\n      loading: !channel.initialized\n    })),\n    state = _o[0],\n    dispatch = _o[1];\n  var isMounted = useIsMounted();\n  var originalTitle = useRef('');\n  var lastRead = useRef(new Date());\n  var online = useRef(true);\n  var channelCapabilitiesArray = (_a = channel.data) === null || _a === void 0 ? void 0 : _a.own_capabilities;\n  var emojiConfig = {\n    commonEmoji: commonEmoji,\n    defaultMinimalEmojis: defaultMinimalEmojis,\n    emojiData: emojiData,\n    emojiSetDef: emojiSetDef\n  };\n  var throttledCopyStateFromChannel = throttle(function () {\n    return dispatch({\n      channel: channel,\n      type: 'copyStateFromChannelOnEvent'\n    });\n  }, 500, {\n    leading: true,\n    trailing: true\n  });\n  var markRead = function markRead() {\n    if (channel.disconnected || !(channelConfig === null || channelConfig === void 0 ? void 0 : channelConfig.read_events)) {\n      return;\n    }\n    lastRead.current = new Date();\n    if (doMarkReadRequest) {\n      doMarkReadRequest(channel);\n    } else {\n      logChatPromiseExecution(channel.markRead(), 'mark read');\n    }\n    if (activeUnreadHandler) {\n      activeUnreadHandler(0, originalTitle.current);\n    } else if (originalTitle.current) {\n      document.title = originalTitle.current;\n    }\n  };\n  var markReadThrottled = throttle(markRead, 500, {\n    leading: true,\n    trailing: true\n  });\n  var handleEvent = function handleEvent(event) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var mainChannelUpdated, unread, messageDate, cid, oldestID;\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n      return __generator(this, function (_m) {\n        switch (_m.label) {\n          case 0:\n            if (event.message) {\n              dispatch({\n                channel: channel,\n                message: event.message,\n                type: 'updateThreadOnEvent'\n              });\n            }\n            if (event.type === 'user.watching.start' || event.type === 'user.watching.stop') return [2 /*return*/];\n            if (event.type === 'typing.start' || event.type === 'typing.stop') {\n              return [2 /*return*/, dispatch({\n                channel: channel,\n                type: 'setTyping'\n              })];\n            }\n            if (event.type === 'connection.changed' && typeof event.online === 'boolean') {\n              online.current = event.online;\n            }\n            if (event.type === 'message.new') {\n              mainChannelUpdated = true;\n              if (((_a = event.message) === null || _a === void 0 ? void 0 : _a.parent_id) && !((_b = event.message) === null || _b === void 0 ? void 0 : _b.show_in_channel)) {\n                mainChannelUpdated = false;\n              }\n              if (mainChannelUpdated && ((_d = (_c = event.message) === null || _c === void 0 ? void 0 : _c.user) === null || _d === void 0 ? void 0 : _d.id) !== client.userID) {\n                if (!document.hidden) {\n                  markReadThrottled();\n                } else if ((channelConfig === null || channelConfig === void 0 ? void 0 : channelConfig.read_events) && !channel.muteStatus().muted) {\n                  unread = channel.countUnread(lastRead.current);\n                  if (activeUnreadHandler) {\n                    activeUnreadHandler(unread, originalTitle.current);\n                  } else {\n                    document.title = \"(\".concat(unread, \") \").concat(originalTitle.current);\n                  }\n                }\n              }\n              if (((_f = (_e = event.message) === null || _e === void 0 ? void 0 : _e.user) === null || _f === void 0 ? void 0 : _f.id) === client.userID && ((_g = event === null || event === void 0 ? void 0 : event.message) === null || _g === void 0 ? void 0 : _g.created_at) && ((_h = event === null || event === void 0 ? void 0 : event.message) === null || _h === void 0 ? void 0 : _h.cid)) {\n                messageDate = new Date(event.message.created_at);\n                cid = event.message.cid;\n                if (!latestMessageDatesByChannels[cid] || latestMessageDatesByChannels[cid].getTime() < messageDate.getTime()) {\n                  latestMessageDatesByChannels[cid] = messageDate;\n                }\n              }\n            }\n            if (!(event.type === 'user.deleted')) return [3 /*break*/, 2];\n            oldestID = (_l = (_k = (_j = channel.state) === null || _j === void 0 ? void 0 : _j.messages) === null || _k === void 0 ? void 0 : _k[0]) === null || _l === void 0 ? void 0 : _l.id;\n            /**\n             * As the channel state is not normalized we re-fetch the channel data. Thus, we avoid having to search for user references in the channel state.\n             */\n            return [4 /*yield*/, channel.query({\n              messages: {\n                id_lt: oldestID,\n                limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE\n              },\n              watchers: {\n                limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE\n              }\n            })];\n          case 1:\n            /**\n             * As the channel state is not normalized we re-fetch the channel data. Thus, we avoid having to search for user references in the channel state.\n             */\n            _m.sent();\n            _m.label = 2;\n          case 2:\n            throttledCopyStateFromChannel();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  // useLayoutEffect here to prevent spinner. Use Suspense when it is available in stable release\n  useLayoutEffect(function () {\n    var errored = false;\n    var done = false;\n    var onVisibilityChange = function onVisibilityChange() {\n      if (!document.hidden) markRead();\n    };\n    (function () {\n      return __awaiter(void 0, void 0, void 0, function () {\n        var config, e_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!channel.initialized) return [3 /*break*/, 4];\n              _a.label = 1;\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n              return [4 /*yield*/, channel.watch()];\n            case 2:\n              _a.sent();\n              config = channel.getConfig();\n              setChannelConfig(config);\n              return [3 /*break*/, 4];\n            case 3:\n              e_1 = _a.sent();\n              dispatch({\n                error: e_1,\n                type: 'setError'\n              });\n              errored = true;\n              return [3 /*break*/, 4];\n            case 4:\n              done = true;\n              originalTitle.current = document.title;\n              if (!errored) {\n                dispatch({\n                  channel: channel,\n                  type: 'initStateFromChannel'\n                });\n                if (channel.countUnread() > 0) markRead();\n                // The more complex sync logic is done in Chat\n                document.addEventListener('visibilitychange', onVisibilityChange);\n                client.on('connection.changed', handleEvent);\n                client.on('connection.recovered', handleEvent);\n                client.on('user.updated', handleEvent);\n                client.on('user.deleted', handleEvent);\n                channel.on(handleEvent);\n              }\n              return [2 /*return*/];\n          }\n        });\n      });\n    })();\n\n    return function () {\n      if (errored || !done) return;\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n      channel === null || channel === void 0 ? void 0 : channel.off(handleEvent);\n      client.off('connection.changed', handleEvent);\n      client.off('connection.recovered', handleEvent);\n      client.off('user.updated', handleEvent);\n      client.off('user.deleted', handleEvent);\n      notificationTimeouts.forEach(clearTimeout);\n    };\n  }, [channel.cid, doMarkReadRequest, channelConfig === null || channelConfig === void 0 ? void 0 : channelConfig.read_events]);\n  useEffect(function () {\n    var _a;\n    if (!state.thread) return;\n    var message = (_a = state.messages) === null || _a === void 0 ? void 0 : _a.find(function (m) {\n      var _a;\n      return m.id === ((_a = state.thread) === null || _a === void 0 ? void 0 : _a.id);\n    });\n    if (message) dispatch({\n      message: message,\n      type: 'setThread'\n    });\n  }, [state.messages, state.thread]);\n  /** MESSAGE */\n  // Adds a temporary notification to message list, will be removed after 5 seconds\n  var addNotification = makeAddNotifications(setNotifications, notificationTimeouts);\n  var loadMoreFinished = debounce(function (hasMore, messages) {\n    if (!isMounted.current) return;\n    dispatch({\n      hasMore: hasMore,\n      messages: messages,\n      type: 'loadMoreFinished'\n    });\n  }, 2000, {\n    leading: true,\n    trailing: true\n  });\n  var loadMore = function loadMore(limit) {\n    if (limit === void 0) {\n      limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE;\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n      var oldestMessage, notHasMore, oldestID, perPage, queryResponse, e_2, hasMoreMessages;\n      var _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!online.current || !window.navigator.onLine) return [2 /*return*/, 0];\n            oldestMessage = (_a = state === null || state === void 0 ? void 0 : state.messages) === null || _a === void 0 ? void 0 : _a[0];\n            if (state.loadingMore || state.loadingMoreNewer || (oldestMessage === null || oldestMessage === void 0 ? void 0 : oldestMessage.status) !== 'received') {\n              return [2 /*return*/, 0];\n            }\n            notHasMore = hasNotMoreMessages(channel.state.messages.length, DEFAULT_INITIAL_CHANNEL_PAGE_SIZE);\n            if (notHasMore) {\n              loadMoreFinished(false, channel.state.messages);\n              return [2 /*return*/, channel.state.messages.length];\n            }\n            dispatch({\n              loadingMore: true,\n              type: 'setLoadingMore'\n            });\n            oldestID = oldestMessage === null || oldestMessage === void 0 ? void 0 : oldestMessage.id;\n            perPage = limit;\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, channel.query({\n              messages: {\n                id_lt: oldestID,\n                limit: perPage\n              },\n              watchers: {\n                limit: perPage\n              }\n            })];\n          case 2:\n            queryResponse = _b.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            e_2 = _b.sent();\n            console.warn('message pagination request failed with error', e_2);\n            dispatch({\n              loadingMore: false,\n              type: 'setLoadingMore'\n            });\n            return [2 /*return*/, 0];\n          case 4:\n            hasMoreMessages = queryResponse.messages.length === perPage;\n            loadMoreFinished(hasMoreMessages, channel.state.messages);\n            return [2 /*return*/, queryResponse.messages.length];\n        }\n      });\n    });\n  };\n  var loadMoreNewer = function loadMoreNewer(limit) {\n    if (limit === void 0) {\n      limit = 100;\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n      var newestMessage, newestId, perPage, queryResponse, e_3, hasMoreNewer;\n      var _a, _b;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!online.current || !window.navigator.onLine) return [2 /*return*/, 0];\n            newestMessage = (_a = state === null || state === void 0 ? void 0 : state.messages) === null || _a === void 0 ? void 0 : _a[((_b = state === null || state === void 0 ? void 0 : state.messages) === null || _b === void 0 ? void 0 : _b.length) - 1];\n            if (state.loadingMore || state.loadingMoreNewer) return [2 /*return*/, 0];\n            dispatch({\n              loadingMoreNewer: true,\n              type: 'setLoadingMoreNewer'\n            });\n            newestId = newestMessage === null || newestMessage === void 0 ? void 0 : newestMessage.id;\n            perPage = limit;\n            _c.label = 1;\n          case 1:\n            _c.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, channel.query({\n              messages: {\n                id_gt: newestId,\n                limit: perPage\n              },\n              watchers: {\n                limit: perPage\n              }\n            })];\n          case 2:\n            queryResponse = _c.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            e_3 = _c.sent();\n            console.warn('message pagination request failed with error', e_3);\n            dispatch({\n              loadingMoreNewer: false,\n              type: 'setLoadingMoreNewer'\n            });\n            return [2 /*return*/, 0];\n          case 4:\n            hasMoreNewer = channel.state.messages !== channel.state.latestMessages;\n            dispatch({\n              hasMoreNewer: hasMoreNewer,\n              messages: channel.state.messages,\n              type: 'loadMoreNewerFinished'\n            });\n            return [2 /*return*/, queryResponse.messages.length];\n        }\n      });\n    });\n  };\n  var clearHighlightedMessageTimeoutId = useRef(null);\n  var jumpToMessage = function jumpToMessage(messageId, messageLimit) {\n    if (messageLimit === void 0) {\n      messageLimit = 100;\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n      var indexOfMessage, hasMoreMessages;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            dispatch({\n              loadingMore: true,\n              type: 'setLoadingMore'\n            });\n            return [4 /*yield*/, channel.state.loadMessageIntoState(messageId, undefined, messageLimit)];\n          case 1:\n            _a.sent();\n            indexOfMessage = channel.state.messages.findIndex(function (message) {\n              return message.id === messageId;\n            });\n            hasMoreMessages = indexOfMessage >= Math.floor(messageLimit / 2);\n            loadMoreFinished(hasMoreMessages, channel.state.messages);\n            dispatch({\n              hasMoreNewer: channel.state.messages !== channel.state.latestMessages,\n              highlightedMessageId: messageId,\n              type: 'jumpToMessageFinished'\n            });\n            if (clearHighlightedMessageTimeoutId.current) {\n              clearTimeout(clearHighlightedMessageTimeoutId.current);\n            }\n            clearHighlightedMessageTimeoutId.current = setTimeout(function () {\n              clearHighlightedMessageTimeoutId.current = null;\n              dispatch({\n                type: 'clearHighlightedMessage'\n              });\n            }, 500);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  var jumpToLatestMessage = function jumpToLatestMessage() {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var hasMoreOlder;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, channel.state.loadMessageIntoState('latest')];\n          case 1:\n            _a.sent();\n            hasMoreOlder = channel.state.messages.length >= 25;\n            loadMoreFinished(hasMoreOlder, channel.state.messages);\n            dispatch({\n              type: 'jumpToLatestMessage'\n            });\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  var updateMessage = function updateMessage(updatedMessage) {\n    // add the message to the local channel state\n    channel.state.addMessageSorted(updatedMessage, true);\n    dispatch({\n      channel: channel,\n      parentId: state.thread && updatedMessage.parent_id,\n      type: 'copyMessagesFromChannel'\n    });\n  };\n  var isUserResponseArray = function isUserResponseArray(output) {\n    var _a;\n    return ((_a = output[0]) === null || _a === void 0 ? void 0 : _a.id) != null;\n  };\n  var doSendMessage = function doSendMessage(message, customMessageData) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var attachments, id, _a, mentioned_users, parent_id, text, mentions, messageData, messageResponse, existingMessage, i, msg, responseTimestamp, existingMessageTimestamp, responseIsTheNewest, error_1, stringError, parsedError;\n      var _b, _c;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            attachments = message.attachments, id = message.id, _a = message.mentioned_users, mentioned_users = _a === void 0 ? [] : _a, parent_id = message.parent_id, text = message.text;\n            mentions = isUserResponseArray(mentioned_users) ? mentioned_users.map(function (_a) {\n              var id = _a.id;\n              return id;\n            }) : mentioned_users;\n            messageData = __assign({\n              attachments: attachments,\n              id: id,\n              mentioned_users: mentions,\n              parent_id: parent_id,\n              quoted_message_id: parent_id === (quotedMessage === null || quotedMessage === void 0 ? void 0 : quotedMessage.parent_id) ? quotedMessage === null || quotedMessage === void 0 ? void 0 : quotedMessage.id : undefined,\n              text: text\n            }, customMessageData);\n            _d.label = 1;\n          case 1:\n            _d.trys.push([1, 6,, 7]);\n            messageResponse = void 0;\n            if (!doSendMessageRequest) return [3 /*break*/, 3];\n            return [4 /*yield*/, doSendMessageRequest(channel.cid, messageData)];\n          case 2:\n            messageResponse = _d.sent();\n            return [3 /*break*/, 5];\n          case 3:\n            return [4 /*yield*/, channel.sendMessage(messageData)];\n          case 4:\n            messageResponse = _d.sent();\n            _d.label = 5;\n          case 5:\n            existingMessage = void 0;\n            for (i = channel.state.messages.length - 1; i >= 0; i--) {\n              msg = channel.state.messages[i];\n              if (msg.id === messageData.id) {\n                existingMessage = msg;\n                break;\n              }\n            }\n            responseTimestamp = new Date(((_b = messageResponse === null || messageResponse === void 0 ? void 0 : messageResponse.message) === null || _b === void 0 ? void 0 : _b.updated_at) || 0).getTime();\n            existingMessageTimestamp = ((_c = existingMessage === null || existingMessage === void 0 ? void 0 : existingMessage.updated_at) === null || _c === void 0 ? void 0 : _c.getTime()) || 0;\n            responseIsTheNewest = responseTimestamp > existingMessageTimestamp;\n            // Replace the message payload after send is completed\n            // We need to check for the newest message payload, because on slow network, the response can arrive later than WS events message.new, message.updated.\n            // Always override existing message in status \"sending\"\n            if ((messageResponse === null || messageResponse === void 0 ? void 0 : messageResponse.message) && (responseIsTheNewest || (existingMessage === null || existingMessage === void 0 ? void 0 : existingMessage.status) === 'sending')) {\n              updateMessage(__assign(__assign({}, messageResponse.message), {\n                status: 'received'\n              }));\n            }\n            if (quotedMessage && parent_id === (quotedMessage === null || quotedMessage === void 0 ? void 0 : quotedMessage.parent_id)) setQuotedMessage(undefined);\n            return [3 /*break*/, 7];\n          case 6:\n            error_1 = _d.sent();\n            stringError = JSON.stringify(error_1);\n            parsedError = stringError ? JSON.parse(stringError) : {};\n            updateMessage(__assign(__assign({}, message), {\n              error: parsedError,\n              errorStatusCode: parsedError.status || undefined,\n              status: 'failed'\n            }));\n            return [3 /*break*/, 7];\n          case 7:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  var sendMessage = function sendMessage(_a, customMessageData) {\n    var _b = _a.attachments,\n      attachments = _b === void 0 ? [] : _b,\n      _c = _a.mentioned_users,\n      mentioned_users = _c === void 0 ? [] : _c,\n      parent = _a.parent,\n      _d = _a.text,\n      text = _d === void 0 ? '' : _d;\n    return __awaiter(void 0, void 0, void 0, function () {\n      var messagePreview;\n      var _e;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            channel.state.filterErrorMessages();\n            messagePreview = __assign({\n              __html: text,\n              attachments: attachments,\n              created_at: new Date(),\n              html: text,\n              id: (_e = customMessageData === null || customMessageData === void 0 ? void 0 : customMessageData.id) !== null && _e !== void 0 ? _e : \"\".concat(client.userID, \"-\").concat(nanoid()),\n              mentioned_users: mentioned_users,\n              reactions: [],\n              status: 'sending',\n              text: text,\n              type: 'regular',\n              user: client.user\n            }, (parent === null || parent === void 0 ? void 0 : parent.id) ? {\n              parent_id: parent.id\n            } : null);\n            updateMessage(messagePreview);\n            return [4 /*yield*/, doSendMessage(messagePreview, customMessageData)];\n          case 1:\n            _f.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  var retrySendMessage = function retrySendMessage(message) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            updateMessage(__assign(__assign({}, message), {\n              errorStatusCode: undefined,\n              status: 'sending'\n            }));\n            return [4 /*yield*/, doSendMessage(message)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  var removeMessage = function removeMessage(message) {\n    channel.state.removeMessage(message);\n    dispatch({\n      channel: channel,\n      parentId: state.thread && message.parent_id,\n      type: 'copyMessagesFromChannel'\n    });\n  };\n  /** THREAD */\n  var openThread = function openThread(message, event) {\n    event === null || event === void 0 ? void 0 : event.preventDefault();\n    setQuotedMessage(function (current) {\n      if ((current === null || current === void 0 ? void 0 : current.parent_id) !== (message === null || message === void 0 ? void 0 : message.parent_id)) {\n        return undefined;\n      } else {\n        return current;\n      }\n    });\n    dispatch({\n      channel: channel,\n      message: message,\n      type: 'openThread'\n    });\n  };\n  var closeThread = function closeThread(event) {\n    event === null || event === void 0 ? void 0 : event.preventDefault();\n    dispatch({\n      type: 'closeThread'\n    });\n  };\n  var loadMoreThreadFinished = debounce(function (threadHasMore, threadMessages) {\n    dispatch({\n      threadHasMore: threadHasMore,\n      threadMessages: threadMessages,\n      type: 'loadMoreThreadFinished'\n    });\n  }, 2000, {\n    leading: true,\n    trailing: true\n  });\n  var loadMoreThread = function loadMoreThread(limit) {\n    if (limit === void 0) {\n      limit = DEFAULT_THREAD_PAGE_SIZE;\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n      var parentID, oldMessages, oldestMessageID, queryResponse, threadHasMoreMessages, newThreadMessages, e_4;\n      var _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (state.threadLoadingMore || !state.thread) return [2 /*return*/];\n            dispatch({\n              type: 'startLoadingThread'\n            });\n            parentID = state.thread.id;\n            if (!parentID) {\n              return [2 /*return*/, dispatch({\n                type: 'closeThread'\n              })];\n            }\n            oldMessages = channel.state.threads[parentID] || [];\n            oldestMessageID = (_a = oldMessages[0]) === null || _a === void 0 ? void 0 : _a.id;\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, channel.getReplies(parentID, {\n              id_lt: oldestMessageID,\n              limit: limit\n            })];\n          case 2:\n            queryResponse = _b.sent();\n            threadHasMoreMessages = hasMoreMessagesProbably(queryResponse.messages.length, limit);\n            newThreadMessages = channel.state.threads[parentID] || [];\n            // next set loadingMore to false so we can start asking for more data\n            loadMoreThreadFinished(threadHasMoreMessages, newThreadMessages);\n            return [3 /*break*/, 4];\n          case 3:\n            e_4 = _b.sent();\n            loadMoreThreadFinished(false, oldMessages);\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  var onMentionsHoverOrClick = useMentionsHandlers(onMentionsHover, onMentionsClick);\n  var editMessage = useEditMessageHandler(doUpdateMessageRequest);\n  var typing = state.typing,\n    restState = __rest(state, [\"typing\"]);\n  var channelStateContextValue = useCreateChannelStateContext(__assign(__assign({}, restState), {\n    acceptedFiles: acceptedFiles,\n    channel: channel,\n    channelCapabilitiesArray: channelCapabilitiesArray,\n    channelConfig: channelConfig,\n    dragAndDropWindow: dragAndDropWindow,\n    giphyVersion: props.giphyVersion || 'fixed_height',\n    imageAttachmentSizeHandler: props.imageAttachmentSizeHandler || getImageAttachmentConfiguration,\n    maxNumberOfFiles: maxNumberOfFiles,\n    multipleUploads: multipleUploads,\n    mutes: mutes,\n    notifications: notifications,\n    quotedMessage: quotedMessage,\n    shouldGenerateVideoThumbnail: props.shouldGenerateVideoThumbnail || true,\n    videoAttachmentSizeHandler: props.videoAttachmentSizeHandler || getVideoAttachmentConfiguration,\n    watcher_count: state.watcherCount\n  }));\n  var channelActionContextValue = useMemo(function () {\n    return {\n      addNotification: addNotification,\n      closeThread: closeThread,\n      dispatch: dispatch,\n      editMessage: editMessage,\n      jumpToLatestMessage: jumpToLatestMessage,\n      jumpToMessage: jumpToMessage,\n      loadMore: loadMore,\n      loadMoreNewer: loadMoreNewer,\n      loadMoreThread: loadMoreThread,\n      onMentionsClick: onMentionsHoverOrClick,\n      onMentionsHover: onMentionsHoverOrClick,\n      openThread: openThread,\n      removeMessage: removeMessage,\n      retrySendMessage: retrySendMessage,\n      sendMessage: sendMessage,\n      setQuotedMessage: setQuotedMessage,\n      skipMessageDataMemoization: skipMessageDataMemoization,\n      updateMessage: updateMessage\n    };\n  }, [channel.cid, loadMore, loadMoreNewer, quotedMessage, jumpToMessage, jumpToLatestMessage]);\n  var componentContextValue = useMemo(function () {\n    return {\n      Attachment: props.Attachment || DefaultAttachment,\n      AutocompleteSuggestionHeader: props.AutocompleteSuggestionHeader,\n      AutocompleteSuggestionItem: props.AutocompleteSuggestionItem,\n      AutocompleteSuggestionList: props.AutocompleteSuggestionList,\n      Avatar: props.Avatar,\n      CooldownTimer: props.CooldownTimer,\n      DateSeparator: props.DateSeparator,\n      EditMessageInput: props.EditMessageInput,\n      EmojiIcon: props.EmojiIcon,\n      EmptyStateIndicator: props.EmptyStateIndicator,\n      FileUploadIcon: props.FileUploadIcon,\n      GiphyPreviewMessage: props.GiphyPreviewMessage,\n      HeaderComponent: props.HeaderComponent,\n      Input: props.Input,\n      LoadingIndicator: props.LoadingIndicator,\n      Message: props.Message || MessageSimple,\n      MessageDeleted: props.MessageDeleted,\n      MessageListNotifications: props.MessageListNotifications,\n      MessageNotification: props.MessageNotification,\n      MessageOptions: props.MessageOptions,\n      MessageRepliesCountButton: props.MessageRepliesCountButton,\n      MessageStatus: props.MessageStatus,\n      MessageSystem: props.MessageSystem,\n      MessageTimestamp: props.MessageTimestamp,\n      ModalGallery: props.ModalGallery,\n      PinIndicator: props.PinIndicator,\n      QuotedMessage: props.QuotedMessage,\n      QuotedMessagePreview: props.QuotedMessagePreview,\n      ReactionSelector: props.ReactionSelector,\n      ReactionsList: props.ReactionsList,\n      SendButton: props.SendButton,\n      ThreadHead: props.ThreadHead,\n      ThreadHeader: props.ThreadHeader,\n      ThreadStart: props.ThreadStart,\n      TriggerProvider: props.TriggerProvider,\n      TypingIndicator: props.TypingIndicator,\n      VirtualMessage: props.VirtualMessage\n    };\n  }, []);\n  var emojiContextValue = useMemo(function () {\n    return {\n      Emoji: props.Emoji,\n      emojiConfig: emojiConfig,\n      EmojiIndex: props.EmojiIndex,\n      EmojiPicker: props.EmojiPicker\n    };\n  }, []);\n  var typingContextValue = useCreateTypingContext({\n    typing: typing\n  });\n  var className = clsx(chatClass, theme, channelClass);\n  if (state.error) {\n    return React.createElement(\"div\", {\n      className: className\n    }, React.createElement(LoadingErrorIndicator, {\n      error: state.error\n    }));\n  }\n  if (state.loading) {\n    return React.createElement(\"div\", {\n      className: className\n    }, React.createElement(LoadingIndicator, null));\n  }\n  if (!channel.watch) {\n    return React.createElement(\"div\", {\n      className: className\n    }, React.createElement(\"div\", null, t('Channel Missing')));\n  }\n  return React.createElement(\"div\", {\n    className: clsx(className, windowsEmojiClass)\n  }, React.createElement(ChannelStateProvider, {\n    value: channelStateContextValue\n  }, React.createElement(ChannelActionProvider, {\n    value: channelActionContextValue\n  }, React.createElement(ComponentProvider, {\n    value: componentContextValue\n  }, React.createElement(EmojiProvider, {\n    value: emojiContextValue\n  }, React.createElement(TypingProvider, {\n    value: typingContextValue\n  }, React.createElement(\"div\", {\n    className: \"\".concat(chatContainerClass)\n  }, dragAndDropWindow && React.createElement(DropzoneProvider, __assign({}, optionalMessageInputProps), children), !dragAndDropWindow && React.createElement(React.Fragment, null, children))))))));\n};\n/**\n * A wrapper component that provides channel data and renders children.\n * The Channel component provides the following contexts:\n * - [ChannelStateContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_state_context/)\n * - [ChannelActionContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_action_context/)\n * - [ComponentContext](https://getstream.io/chat/docs/sdk/react/contexts/component_context/)\n * - [EmojiContext](https://getstream.io/chat/docs/sdk/react/contexts/emoji_context/)\n * - [TypingContext](https://getstream.io/chat/docs/sdk/react/contexts/typing_context/)\n */\nexport var Channel = React.memo(UnMemoizedChannel);","map":null,"metadata":{},"sourceType":"module"}