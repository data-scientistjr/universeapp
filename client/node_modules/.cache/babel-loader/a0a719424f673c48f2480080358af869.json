{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport clsx from 'clsx';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { Virtuoso } from 'react-virtuoso';\nimport { GiphyPreviewMessage as DefaultGiphyPreviewMessage } from './GiphyPreviewMessage';\nimport { useGiphyPreview } from './hooks/useGiphyPreview';\nimport { useNewMessageNotification } from './hooks/useNewMessageNotification';\nimport { usePrependedMessagesCount } from './hooks/usePrependMessagesCount';\nimport { useShouldForceScrollToBottom } from './hooks/useShouldForceScrollToBottom';\nimport { MessageNotification as DefaultMessageNotification } from './MessageNotification';\nimport { MessageListNotifications as DefaultMessageListNotifications } from './MessageListNotifications';\nimport { MessageListMainPanel } from './MessageListMainPanel';\nimport { getGroupStyles, processMessages } from './utils';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { DateSeparator as DefaultDateSeparator } from '../DateSeparator/DateSeparator';\nimport { EmptyStateIndicator as DefaultEmptyStateIndicator } from '../EmptyStateIndicator/EmptyStateIndicator';\nimport { EventComponent } from '../EventComponent/EventComponent';\nimport { LoadingIndicator as DefaultLoadingIndicator } from '../Loading/LoadingIndicator';\nimport { Message, MessageSimple } from '../Message';\nimport { useChannelActionContext } from '../../context/ChannelActionContext';\nimport { useChannelStateContext } from '../../context/ChannelStateContext';\nimport { useChatContext } from '../../context/ChatContext';\nimport { useComponentContext } from '../../context/ComponentContext';\nimport { isDate } from '../../context/TranslationContext';\nvar PREPEND_OFFSET = Math.pow(10, 7);\nfunction captureResizeObserverExceededError(e) {\n  if (e.message === 'ResizeObserver loop completed with undelivered notifications.' || e.message === 'ResizeObserver loop limit exceeded') {\n    e.stopImmediatePropagation();\n  }\n}\nfunction useCaptureResizeObserverExceededError() {\n  useEffect(function () {\n    window.addEventListener('error', captureResizeObserverExceededError);\n    return function () {\n      window.removeEventListener('error', captureResizeObserverExceededError);\n    };\n  }, []);\n}\nfunction fractionalItemSize(element) {\n  return element.getBoundingClientRect().height;\n}\nfunction findMessageIndex(messages, id) {\n  return messages.findIndex(function (message) {\n    return message.id === id;\n  });\n}\nfunction calculateInitialTopMostItemIndex(messages, highlightedMessageId) {\n  if (highlightedMessageId) {\n    var index = findMessageIndex(messages, highlightedMessageId);\n    if (index !== -1) {\n      return {\n        align: 'center',\n        index: index\n      };\n    }\n  }\n  return messages.length - 1;\n}\nvar VirtualizedMessageListWithContext = function VirtualizedMessageListWithContext(props) {\n  var additionalVirtuosoProps = props.additionalVirtuosoProps,\n    channel = props.channel,\n    closeReactionSelectorOnClick = props.closeReactionSelectorOnClick,\n    customMessageRenderer = props.customMessageRenderer,\n    defaultItemHeight = props.defaultItemHeight,\n    _a = props.disableDateSeparator,\n    disableDateSeparator = _a === void 0 ? true : _a,\n    groupStyles = props.groupStyles,\n    hasMore = props.hasMore,\n    hasMoreNewer = props.hasMoreNewer,\n    head = props.head,\n    _b = props.hideDeletedMessages,\n    hideDeletedMessages = _b === void 0 ? false : _b,\n    _c = props.hideNewMessageSeparator,\n    hideNewMessageSeparator = _c === void 0 ? false : _c,\n    highlightedMessageId = props.highlightedMessageId,\n    jumpToLatestMessage = props.jumpToLatestMessage,\n    loadingMore = props.loadingMore,\n    loadMore = props.loadMore,\n    loadMoreNewer = props.loadMoreNewer,\n    propMessage = props.Message,\n    _d = props.messageLimit,\n    messageLimit = _d === void 0 ? 100 : _d,\n    messages = props.messages,\n    notifications = props.notifications,\n    // TODO: refactor to scrollSeekPlaceHolderConfiguration and components.ScrollSeekPlaceholder, like the Virtuoso Component\n    _e = props.overscan,\n    // TODO: refactor to scrollSeekPlaceHolderConfiguration and components.ScrollSeekPlaceholder, like the Virtuoso Component\n    overscan = _e === void 0 ? 0 : _e,\n    scrollSeekPlaceHolder = props.scrollSeekPlaceHolder,\n    _f = props.scrollToLatestMessageOnFocus,\n    scrollToLatestMessageOnFocus = _f === void 0 ? false : _f,\n    _g = props.separateGiphyPreview,\n    separateGiphyPreview = _g === void 0 ? false : _g,\n    _h = props.shouldGroupByUser,\n    shouldGroupByUser = _h === void 0 ? false : _h,\n    _j = props.stickToBottomScrollBehavior,\n    stickToBottomScrollBehavior = _j === void 0 ? 'smooth' : _j,\n    suppressAutoscroll = props.suppressAutoscroll,\n    threadList = props.threadList;\n  // Stops errors generated from react-virtuoso to bubble up\n  // to Sentry or other tracking tools.\n  useCaptureResizeObserverExceededError();\n  var _k = useComponentContext('VirtualizedMessageList'),\n    _l = _k.DateSeparator,\n    DateSeparator = _l === void 0 ? DefaultDateSeparator : _l,\n    _m = _k.EmptyStateIndicator,\n    EmptyStateIndicator = _m === void 0 ? DefaultEmptyStateIndicator : _m,\n    _o = _k.GiphyPreviewMessage,\n    GiphyPreviewMessage = _o === void 0 ? DefaultGiphyPreviewMessage : _o,\n    _p = _k.LoadingIndicator,\n    LoadingIndicator = _p === void 0 ? DefaultLoadingIndicator : _p,\n    _q = _k.MessageListNotifications,\n    MessageListNotifications = _q === void 0 ? DefaultMessageListNotifications : _q,\n    _r = _k.MessageNotification,\n    MessageNotification = _r === void 0 ? DefaultMessageNotification : _r,\n    _s = _k.MessageSystem,\n    MessageSystem = _s === void 0 ? EventComponent : _s,\n    _t = _k.TypingIndicator,\n    TypingIndicator = _t === void 0 ? null : _t,\n    _u = _k.VirtualMessage,\n    contextMessage = _u === void 0 ? MessageSimple : _u;\n  var _v = useChatContext('VirtualizedMessageList'),\n    client = _v.client,\n    customClasses = _v.customClasses;\n  var lastRead = useMemo(function () {\n    var _a;\n    return (_a = channel.lastRead) === null || _a === void 0 ? void 0 : _a.call(channel);\n  }, [channel]);\n  var MessageUIComponent = propMessage || contextMessage;\n  var _w = useGiphyPreview(separateGiphyPreview),\n    giphyPreviewMessage = _w.giphyPreviewMessage,\n    setGiphyPreviewMessage = _w.setGiphyPreviewMessage;\n  var processedMessages = useMemo(function () {\n    if (typeof messages === 'undefined') {\n      return [];\n    }\n    if (disableDateSeparator && !hideDeletedMessages && hideNewMessageSeparator && !separateGiphyPreview) {\n      return messages;\n    }\n    return processMessages({\n      enableDateSeparator: !disableDateSeparator,\n      hideDeletedMessages: hideDeletedMessages,\n      hideNewMessageSeparator: hideNewMessageSeparator,\n      lastRead: lastRead,\n      messages: messages,\n      setGiphyPreviewMessage: setGiphyPreviewMessage,\n      userId: client.userID || ''\n    });\n  }, [disableDateSeparator, hideDeletedMessages, hideNewMessageSeparator, lastRead, messages, messages === null || messages === void 0 ? void 0 : messages.length, client.userID]);\n  var groupStylesFn = groupStyles || getGroupStyles;\n  var messageGroupStyles = useMemo(function () {\n    return processedMessages.reduce(function (acc, message, i) {\n      var style = groupStylesFn(message, processedMessages[i - 1], processedMessages[i + 1], !shouldGroupByUser);\n      if (style) acc[message.id] = style;\n      return acc;\n    }, {});\n  },\n  // processedMessages were incorrectly rebuilt with a new object identity at some point, hence the .length usage\n  [processedMessages.length, shouldGroupByUser]);\n  var virtuoso = useRef(null);\n  var _x = useNewMessageNotification(processedMessages, client.userID, hasMoreNewer),\n    atBottom = _x.atBottom,\n    isMessageListScrolledToBottom = _x.isMessageListScrolledToBottom,\n    newMessagesNotification = _x.newMessagesNotification,\n    setIsMessageListScrolledToBottom = _x.setIsMessageListScrolledToBottom,\n    setNewMessagesNotification = _x.setNewMessagesNotification;\n  var scrollToBottom = useCallback(function () {\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!hasMoreNewer) return [3 /*break*/, 2];\n            return [4 /*yield*/, jumpToLatestMessage()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n          case 2:\n            if (virtuoso.current) {\n              virtuoso.current.scrollToIndex(processedMessages.length - 1);\n            }\n            setNewMessagesNotification(false);\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [virtuoso, processedMessages, setNewMessagesNotification,\n  // processedMessages were incorrectly rebuilt with a new object identity at some point, hence the .length usage\n  processedMessages.length, hasMoreNewer, jumpToLatestMessage]);\n  var _y = React.useState(false),\n    newMessagesReceivedInBackground = _y[0],\n    setNewMessagesReceivedInBackground = _y[1];\n  var resetNewMessagesReceivedInBackground = useCallback(function () {\n    setNewMessagesReceivedInBackground(false);\n  }, []);\n  useEffect(function () {\n    setNewMessagesReceivedInBackground(true);\n  }, [messages]);\n  var scrollToBottomIfConfigured = useCallback(function (event) {\n    if (scrollToLatestMessageOnFocus && event.target === window) {\n      if (newMessagesReceivedInBackground) {\n        setTimeout(scrollToBottom, 100);\n      }\n    }\n  }, [scrollToLatestMessageOnFocus, scrollToBottom, newMessagesReceivedInBackground]);\n  useEffect(function () {\n    if (typeof window !== 'undefined') {\n      window.addEventListener('focus', scrollToBottomIfConfigured);\n      window.addEventListener('blur', resetNewMessagesReceivedInBackground);\n    }\n    return function () {\n      window.removeEventListener('focus', scrollToBottomIfConfigured);\n      window.removeEventListener('blur', resetNewMessagesReceivedInBackground);\n    };\n  }, [scrollToBottomIfConfigured]);\n  var numItemsPrepended = usePrependedMessagesCount(processedMessages, !disableDateSeparator);\n  /**\n   * Logic to update the key of the virtuoso component when the list jumps to a new location.\n   */\n  var _z = useState(+new Date()),\n    messageSetKey = _z[0],\n    setMessageSetKey = _z[1];\n  var firstMessageId = useRef();\n  useEffect(function () {\n    var _a;\n    var continuousSet = messages === null || messages === void 0 ? void 0 : messages.find(function (message) {\n      return message.id === firstMessageId.current;\n    });\n    if (!continuousSet) {\n      setMessageSetKey(+new Date());\n    }\n    firstMessageId.current = (_a = messages === null || messages === void 0 ? void 0 : messages[0]) === null || _a === void 0 ? void 0 : _a.id;\n  }, [messages]);\n  var shouldForceScrollToBottom = useShouldForceScrollToBottom(processedMessages, client.userID);\n  var followOutput = function followOutput(isAtBottom) {\n    if (hasMoreNewer || suppressAutoscroll) {\n      return false;\n    }\n    if (shouldForceScrollToBottom()) {\n      return isAtBottom ? stickToBottomScrollBehavior : 'auto';\n    }\n    // a message from another user has been received - don't scroll to bottom unless already there\n    return isAtBottom ? stickToBottomScrollBehavior : false;\n  };\n  var messageRenderer = useCallback(function (messageList, virtuosoIndex) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    var streamMessageIndex = virtuosoIndex + numItemsPrepended - PREPEND_OFFSET;\n    // use custom renderer supplied by client if present and skip the rest\n    if (customMessageRenderer) {\n      return customMessageRenderer(messageList, streamMessageIndex);\n    }\n    var message = messageList[streamMessageIndex];\n    if (message.customType === CUSTOM_MESSAGE_TYPE.date && message.date && isDate(message.date)) {\n      return React.createElement(DateSeparator, {\n        date: message.date,\n        unread: message.unread\n      });\n    }\n    if (!message) return React.createElement(\"div\", {\n      style: {\n        height: '1px'\n      }\n    }); // returning null or zero height breaks the virtuoso\n    if (message.type === 'system') {\n      return React.createElement(MessageSystem, {\n        message: message\n      });\n    }\n    var groupedByUser = shouldGroupByUser && streamMessageIndex > 0 && ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) === ((_b = messageList[streamMessageIndex - 1].user) === null || _b === void 0 ? void 0 : _b.id);\n    var firstOfGroup = shouldGroupByUser && ((_c = message.user) === null || _c === void 0 ? void 0 : _c.id) !== ((_e = (_d = messageList[streamMessageIndex - 1]) === null || _d === void 0 ? void 0 : _d.user) === null || _e === void 0 ? void 0 : _e.id);\n    var endOfGroup = shouldGroupByUser && ((_f = message.user) === null || _f === void 0 ? void 0 : _f.id) !== ((_h = (_g = messageList[streamMessageIndex + 1]) === null || _g === void 0 ? void 0 : _g.user) === null || _h === void 0 ? void 0 : _h.id);\n    return React.createElement(Message, {\n      autoscrollToBottom: (_j = virtuoso.current) === null || _j === void 0 ? void 0 : _j.autoscrollToBottom,\n      closeReactionSelectorOnClick: closeReactionSelectorOnClick,\n      customMessageActions: props.customMessageActions,\n      endOfGroup: endOfGroup,\n      firstOfGroup: firstOfGroup,\n      groupedByUser: groupedByUser,\n      message: message,\n      Message: MessageUIComponent,\n      messageActions: props.messageActions\n    });\n  }, [customMessageRenderer, shouldGroupByUser, numItemsPrepended]);\n  var Item = useMemo(function () {\n    // using 'display: inline-block'\n    // traps CSS margins of the item elements, preventing incorrect item measurements\n    var Item = function Item(props) {\n      var _a;\n      var streamMessageIndex = props['data-item-index'] + numItemsPrepended - PREPEND_OFFSET;\n      var message = processedMessages[streamMessageIndex];\n      var groupStyles = messageGroupStyles[message.id] || '';\n      return React.createElement(\"div\", __assign({}, props, {\n        className: (customClasses === null || customClasses === void 0 ? void 0 : customClasses.virtualMessage) || clsx('str-chat__virtual-list-message-wrapper str-chat__li', (_a = {}, _a[\"str-chat__li--\".concat(groupStyles)] = groupStyles, _a))\n      }));\n    };\n    return Item;\n  }, [customClasses === null || customClasses === void 0 ? void 0 : customClasses.virtualMessage, numItemsPrepended,\n  // processedMessages were incorrectly rebuilt with a new object identity at some point, hence the .length usage\n  processedMessages.length]);\n  var virtuosoComponents = useMemo(function () {\n    var EmptyPlaceholder = function EmptyPlaceholder() {\n      return React.createElement(React.Fragment, null, EmptyStateIndicator && React.createElement(EmptyStateIndicator, {\n        listType: threadList ? 'thread' : 'message'\n      }));\n    };\n    var Header = function Header() {\n      return loadingMore ? React.createElement(\"div\", {\n        className: 'str-chat__virtual-list__loading'\n      }, React.createElement(LoadingIndicator, {\n        size: 20\n      })) : head || null;\n    };\n    var Footer = function Footer() {\n      return TypingIndicator ? React.createElement(TypingIndicator, {\n        avatarSize: 24\n      }) : React.createElement(React.Fragment, null);\n    };\n    return {\n      EmptyPlaceholder: EmptyPlaceholder,\n      Footer: Footer,\n      Header: Header,\n      Item: Item\n    };\n  }, [loadingMore, head, Item]);\n  var atBottomStateChange = function atBottomStateChange(isAtBottom) {\n    atBottom.current = isAtBottom;\n    setIsMessageListScrolledToBottom(isAtBottom);\n    if (isAtBottom && newMessagesNotification) {\n      setNewMessagesNotification(false);\n    }\n  };\n  var startReached = function startReached() {\n    if (hasMore && loadMore) {\n      loadMore(messageLimit);\n    }\n  };\n  var endReached = function endReached() {\n    if (hasMoreNewer && loadMoreNewer) {\n      loadMoreNewer(messageLimit);\n    }\n  };\n  useEffect(function () {\n    var _a;\n    if (highlightedMessageId) {\n      var index = findMessageIndex(processedMessages, highlightedMessageId);\n      if (index !== -1) {\n        (_a = virtuoso.current) === null || _a === void 0 ? void 0 : _a.scrollToIndex({\n          align: 'center',\n          index: index\n        });\n      }\n    }\n  }, [highlightedMessageId]);\n  if (!processedMessages) return null;\n  return React.createElement(React.Fragment, null, React.createElement(MessageListMainPanel, null, React.createElement(\"div\", {\n    className: (customClasses === null || customClasses === void 0 ? void 0 : customClasses.virtualizedMessageList) || 'str-chat__virtual-list'\n  }, React.createElement(Virtuoso, __assign({\n    atBottomStateChange: atBottomStateChange,\n    atBottomThreshold: 200,\n    className: 'str-chat__message-list-scroll',\n    components: virtuosoComponents,\n    computeItemKey: function computeItemKey(index) {\n      return processedMessages[numItemsPrepended + index - PREPEND_OFFSET].id;\n    },\n    endReached: endReached,\n    firstItemIndex: PREPEND_OFFSET - numItemsPrepended,\n    followOutput: followOutput,\n    increaseViewportBy: {\n      bottom: 200,\n      top: 0\n    },\n    initialTopMostItemIndex: calculateInitialTopMostItemIndex(processedMessages, highlightedMessageId),\n    itemContent: function itemContent(i) {\n      return messageRenderer(processedMessages, i);\n    },\n    itemSize: fractionalItemSize,\n    key: messageSetKey,\n    overscan: overscan,\n    ref: virtuoso,\n    startReached: startReached,\n    style: {\n      overflowX: 'hidden'\n    },\n    totalCount: processedMessages.length\n  }, additionalVirtuosoProps, scrollSeekPlaceHolder ? {\n    scrollSeek: scrollSeekPlaceHolder\n  } : {}, defaultItemHeight ? {\n    defaultItemHeight: defaultItemHeight\n  } : {})))), React.createElement(MessageListNotifications, {\n    hasNewMessages: newMessagesNotification,\n    isMessageListScrolledToBottom: isMessageListScrolledToBottom,\n    isNotAtLatestMessageSet: hasMoreNewer,\n    MessageNotification: MessageNotification,\n    notifications: notifications,\n    scrollToBottom: scrollToBottom,\n    threadList: threadList\n  }), giphyPreviewMessage && React.createElement(GiphyPreviewMessage, {\n    message: giphyPreviewMessage\n  }));\n};\n/**\n * The VirtualizedMessageList component renders a list of messages in a virtualized list.\n * It is a consumer of the React contexts set in [Channel](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Channel/Channel.tsx).\n */\nexport function VirtualizedMessageList(props) {\n  var _a = useChannelActionContext('VirtualizedMessageList'),\n    jumpToLatestMessage = _a.jumpToLatestMessage,\n    loadMore = _a.loadMore,\n    loadMoreNewer = _a.loadMoreNewer;\n  var _b = useChannelStateContext('VirtualizedMessageList'),\n    channel = _b.channel,\n    hasMore = _b.hasMore,\n    hasMoreNewer = _b.hasMoreNewer,\n    highlightedMessageId = _b.highlightedMessageId,\n    loadingMore = _b.loadingMore,\n    loadingMoreNewer = _b.loadingMoreNewer,\n    contextMessages = _b.messages,\n    notifications = _b.notifications,\n    suppressAutoscroll = _b.suppressAutoscroll;\n  var messages = props.messages || contextMessages;\n  return React.createElement(VirtualizedMessageListWithContext, __assign({\n    channel: channel,\n    hasMore: !!hasMore,\n    hasMoreNewer: !!hasMoreNewer,\n    highlightedMessageId: highlightedMessageId,\n    jumpToLatestMessage: jumpToLatestMessage,\n    loadingMore: !!loadingMore,\n    loadingMoreNewer: !!loadingMoreNewer,\n    loadMore: loadMore,\n    loadMoreNewer: loadMoreNewer,\n    messages: messages,\n    notifications: notifications,\n    suppressAutoscroll: suppressAutoscroll\n  }, props));\n}","map":null,"metadata":{},"sourceType":"module"}