{"ast":null,"code":"import { useMemo, useRef } from 'react';\nvar STATUSES_EXCLUDED_FROM_PREPEND = ['sending', 'failed'];\nexport function usePrependedMessagesCount(messages, hasDateSeparator) {\n  var firstRealMessageIndex = hasDateSeparator ? 1 : 0;\n  var firstMessageId = useRef();\n  var earliestMessageId = useRef();\n  var previousNumItemsPrepended = useRef(0);\n  var numItemsPrepended = useMemo(function () {\n    var _a, _b;\n    if (!messages || !messages.length) {\n      previousNumItemsPrepended.current = 0;\n      return 0;\n    }\n    var currentFirstMessageId = (_a = messages === null || messages === void 0 ? void 0 : messages[firstRealMessageIndex]) === null || _a === void 0 ? void 0 : _a.id;\n    // if no new messages were prepended, return early (same amount as before)\n    if (currentFirstMessageId === earliestMessageId.current) {\n      return previousNumItemsPrepended.current;\n    }\n    if (!firstMessageId.current) {\n      firstMessageId.current = currentFirstMessageId;\n    }\n    earliestMessageId.current = currentFirstMessageId;\n    // if new messages were prepended, find out how many\n    // start with this number because there cannot be fewer prepended items than before\n    var adjustPrependedMessageCount = 0;\n    for (var i = previousNumItemsPrepended.current; i < messages.length; i += 1) {\n      // Optimistic UI update, when sending messages, can lead to a situation, when\n      // the order of the messages changes for a moment. This can happen, when a user\n      // sends multiple messages withing few milliseconds. E.g. we send a message A\n      // then message B. At first we have message array with both messages of status \"sending\"\n      // then response for message A is received with a new - later - created_at timestamp\n      // this leads to rearrangement of 1.B (\"sending\"), 2.A (\"received\"). Still firstMessageId.current\n      // points to message A, but now this message has index 1 => previousNumItemsPrepended.current === 1\n      // That in turn leads to incorrect index calculation in VirtualizedMessageList trying to access a message\n      // at non-existent index. Therefore, we ignore messages of status \"sending\" / \"failed\" in order they are\n      // not considered as prepended messages.\n      if (((_b = messages[i]) === null || _b === void 0 ? void 0 : _b.status) &&\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      STATUSES_EXCLUDED_FROM_PREPEND.includes(messages[i].status) && messages[i].id !== firstMessageId.current) {\n        adjustPrependedMessageCount++;\n      }\n      if (messages[i].id === firstMessageId.current) {\n        previousNumItemsPrepended.current = i - adjustPrependedMessageCount;\n        return previousNumItemsPrepended.current;\n      }\n    }\n    // if no match has found, we have jumped - reset the prepended item count.\n    firstMessageId.current = currentFirstMessageId;\n    previousNumItemsPrepended.current = 0;\n    return 0;\n    // TODO: there's a bug here, the messages prop is the same array instance (something mutates it)\n    // that's why the second dependency is necessary\n  }, [messages, messages === null || messages === void 0 ? void 0 : messages.length]);\n  return numItemsPrepended;\n}","map":null,"metadata":{},"sourceType":"module"}