{"ast":null,"code":"/* eslint-disable no-continue */\nimport { nanoid } from 'nanoid';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { isDate } from '../../context/TranslationContext';\n/**\n * processMessages - Transform the input message list according to config parameters\n *\n * Inserts date separators btw. messages created on different dates or before unread incoming messages. By default:\n * - enabled in main message list\n * - disabled in virtualized message list\n * - disabled in thread\n *\n * Allows to filter out deleted messages, contolled by hideDeletedMessages param. This is disabled by default.\n *\n * Sets Giphy preview message for VirtualizedMessageList\n *\n * The only required params are messages and userId, the rest are config params:\n *\n * @return {StreamMessage<StreamChatGenerics>[]} Transformed list of messages\n */\nexport var processMessages = function processMessages(params) {\n  var _a, _b;\n  var enableDateSeparator = params.enableDateSeparator,\n    hideDeletedMessages = params.hideDeletedMessages,\n    hideNewMessageSeparator = params.hideNewMessageSeparator,\n    lastRead = params.lastRead,\n    messages = params.messages,\n    setGiphyPreviewMessage = params.setGiphyPreviewMessage,\n    userId = params.userId;\n  var unread = false;\n  var ephemeralMessagePresent = false;\n  var lastDateSeparator;\n  var newMessages = [];\n  for (var i = 0; i < messages.length; i += 1) {\n    var message = messages[i];\n    if (hideDeletedMessages && message.type === 'deleted') {\n      continue;\n    }\n    if (setGiphyPreviewMessage && message.type === 'ephemeral' && message.command === 'giphy') {\n      ephemeralMessagePresent = true;\n      setGiphyPreviewMessage(message);\n      continue;\n    }\n    var messageDate = message.created_at && isDate(message.created_at) && message.created_at.toDateString() || '';\n    var previousMessage = messages[i - 1];\n    var prevMessageDate = messageDate;\n    if (enableDateSeparator && (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.created_at) && isDate(previousMessage.created_at)) {\n      prevMessageDate = previousMessage.created_at.toDateString();\n    }\n    if (!unread && !hideNewMessageSeparator) {\n      unread = lastRead && message.created_at && new Date(lastRead) < message.created_at || false;\n      // do not show date separator for current user's messages\n      if (enableDateSeparator && unread && ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) !== userId) {\n        newMessages.push({\n          customType: CUSTOM_MESSAGE_TYPE.date,\n          date: message.created_at,\n          id: makeDateMessageId(message.created_at),\n          unread: unread\n        });\n      }\n    }\n    if (enableDateSeparator && (i === 0 ||\n    // always put date separator before the first message\n    messageDate !== prevMessageDate ||\n    // add date separator btw. 2 messages created on different date\n    // if hiding deleted messages replace the previous deleted message(s) with A separator if the last rendered message was created on different date\n    hideDeletedMessages && (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.type) === 'deleted' && lastDateSeparator !== messageDate) && ((_b = newMessages === null || newMessages === void 0 ? void 0 : newMessages[newMessages.length - 1]) === null || _b === void 0 ? void 0 : _b.customType) !== CUSTOM_MESSAGE_TYPE.date // do not show two date separators in a row)\n    ) {\n      lastDateSeparator = messageDate;\n      newMessages.push({\n        customType: CUSTOM_MESSAGE_TYPE.date,\n        date: message.created_at,\n        id: makeDateMessageId(message.created_at)\n      }, message);\n    } else {\n      newMessages.push(message);\n    }\n  }\n  // clean up the giphy preview component state after a Cancel action\n  if (setGiphyPreviewMessage && !ephemeralMessagePresent) {\n    setGiphyPreviewMessage(undefined);\n  }\n  return newMessages;\n};\nexport var makeDateMessageId = function makeDateMessageId(date) {\n  var idSuffix;\n  try {\n    idSuffix = !date ? nanoid() : date instanceof Date ? date.toISOString() : date;\n  } catch (e) {\n    idSuffix = nanoid();\n  }\n  return \"\".concat(CUSTOM_MESSAGE_TYPE.date, \"-\").concat(idSuffix);\n};\n// fast since it usually iterates just the last few messages\nexport var getLastReceived = function getLastReceived(messages) {\n  for (var i = messages.length - 1; i > 0; i -= 1) {\n    if (messages[i].status === 'received') {\n      return messages[i].id;\n    }\n  }\n  return null;\n};\nexport var getReadStates = function getReadStates(messages, read, returnAllReadData) {\n  if (read === void 0) {\n    read = {};\n  }\n  // create object with empty array for each message id\n  var readData = {};\n  Object.values(read).forEach(function (readState) {\n    if (!readState.last_read) return;\n    var userLastReadMsgId;\n    // loop messages sent by current user and add read data for other users in channel\n    messages.forEach(function (msg) {\n      if (msg.updated_at && msg.updated_at < readState.last_read) {\n        userLastReadMsgId = msg.id;\n        // if true, save other user's read data for all messages they've read\n        if (returnAllReadData) {\n          if (!readData[userLastReadMsgId]) {\n            readData[userLastReadMsgId] = [];\n          }\n          readData[userLastReadMsgId].push(readState.user);\n        }\n      }\n    });\n    // if true, only save read data for other user's last read message\n    if (userLastReadMsgId && !returnAllReadData) {\n      if (!readData[userLastReadMsgId]) {\n        readData[userLastReadMsgId] = [];\n      }\n      readData[userLastReadMsgId].push(readState.user);\n    }\n  });\n  return readData;\n};\nexport var insertIntro = function insertIntro(messages, headerPosition) {\n  var newMessages = messages;\n  var intro = {\n    customType: CUSTOM_MESSAGE_TYPE.intro\n  };\n  // if no headerPosition is set, HeaderComponent will go at the top\n  if (!headerPosition) {\n    newMessages.unshift(intro);\n    return newMessages;\n  }\n  // if no messages, intro gets inserted\n  if (!newMessages.length) {\n    newMessages.unshift(intro);\n    return newMessages;\n  }\n  // else loop over the messages\n  for (var i = 0; i < messages.length; i += 1) {\n    var message = messages[i];\n    var messageTime = message.created_at && isDate(message.created_at) ? message.created_at.getTime() : null;\n    var nextMessage = messages[i + 1];\n    var nextMessageTime = nextMessage.created_at && isDate(nextMessage.created_at) ? nextMessage.created_at.getTime() : null;\n    // header position is smaller than message time so comes after;\n    if (messageTime && messageTime < headerPosition) {\n      // if header position is also smaller than message time continue;\n      if (nextMessageTime && nextMessageTime < headerPosition) {\n        if (messages[i + 1] && messages[i + 1].customType === CUSTOM_MESSAGE_TYPE.date) continue;\n        if (!nextMessageTime) {\n          newMessages.push(intro);\n          return newMessages;\n        }\n      } else {\n        newMessages.splice(i + 1, 0, intro);\n        return newMessages;\n      }\n    }\n  }\n  return newMessages;\n};\nexport var getGroupStyles = function getGroupStyles(message, previousMessage, nextMessage, noGroupByUser) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  if (message.customType === CUSTOM_MESSAGE_TYPE.date) return '';\n  if (message.customType === CUSTOM_MESSAGE_TYPE.intro) return '';\n  if (noGroupByUser || ((_a = message.attachments) === null || _a === void 0 ? void 0 : _a.length) !== 0) return 'single';\n  var isTopMessage = !previousMessage || previousMessage.customType === CUSTOM_MESSAGE_TYPE.intro || previousMessage.customType === CUSTOM_MESSAGE_TYPE.date || previousMessage.type === 'system' || ((_b = previousMessage.attachments) === null || _b === void 0 ? void 0 : _b.length) !== 0 || ((_c = message.user) === null || _c === void 0 ? void 0 : _c.id) !== ((_d = previousMessage.user) === null || _d === void 0 ? void 0 : _d.id) || previousMessage.type === 'error' || previousMessage.deleted_at || message.reaction_counts && Object.keys(message.reaction_counts).length > 0;\n  var isBottomMessage = !nextMessage || nextMessage.customType === CUSTOM_MESSAGE_TYPE.date || nextMessage.type === 'system' || nextMessage.customType === CUSTOM_MESSAGE_TYPE.intro || ((_e = nextMessage.attachments) === null || _e === void 0 ? void 0 : _e.length) !== 0 || ((_f = message.user) === null || _f === void 0 ? void 0 : _f.id) !== ((_g = nextMessage.user) === null || _g === void 0 ? void 0 : _g.id) || nextMessage.type === 'error' || nextMessage.deleted_at || nextMessage.reaction_counts && Object.keys(nextMessage.reaction_counts).length > 0;\n  if (!isTopMessage && !isBottomMessage) {\n    if (message.deleted_at || message.type === 'error') return 'single';\n    return 'middle';\n  }\n  if (isBottomMessage) {\n    if (isTopMessage || message.deleted_at || message.type === 'error') return 'single';\n    return 'bottom';\n  }\n  if (isTopMessage) return 'top';\n  return '';\n};\n// \"Probably\" included, because it may happen that the last page was returned and it has exactly the size of the limit\n// but the back-end cannot provide us with information on whether it has still more messages in the DB\n// FIXME: once the pagination state is moved from Channel to MessageList, these should be moved as well.\n//  The MessageList should have configurable the limit for performing the requests.\n//  This parameter would then be used within these functions\nexport var hasMoreMessagesProbably = function hasMoreMessagesProbably(returnedCountMessages, limit) {\n  return returnedCountMessages === limit;\n};\nexport var hasNotMoreMessages = function hasNotMoreMessages(returnedCountMessages, limit) {\n  return returnedCountMessages < limit;\n};","map":null,"metadata":{},"sourceType":"module"}