{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/ebubechi/Desktop/UniVerse/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/Users/ebubechi/Desktop/UniVerse/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/ebubechi/Desktop/UniVerse/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar StringScanner = require('./StringScanner');\nvar syntax = require('./syntax');\nvar XmlCdata = require('./XmlCdata');\nvar XmlComment = require('./XmlComment');\nvar XmlDocument = require('./XmlDocument');\nvar XmlElement = require('./XmlElement');\nvar XmlProcessingInstruction = require('./XmlProcessingInstruction');\nvar XmlText = require('./XmlText');\nvar emptyString = '';\n\n/**\nParses an XML string into an `XmlDocument`.\n\n@private\n*/\nvar Parser = /*#__PURE__*/function () {\n  /**\n  @param {string} xml\n    XML string to parse.\n   @param {object} [options]\n    Parsing options.\n     @param {boolean} [options.ignoreUndefinedEntities=false]\n    @param {boolean} [options.preserveCdata=false]\n    @param {boolean} [options.preserveComments=false]\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    @param {boolean} [options.sortAttributes=false]\n  */\n  function Parser(xml) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Parser);\n    /** @type {XmlDocument} */\n    this.document = new XmlDocument();\n\n    /** @type {XmlDocument|XmlElement} */\n    this.currentNode = this.document;\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n    this.consumeProlog();\n    if (!this.consumeElement()) {\n      this.error('Root element is missing or invalid');\n    }\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (!this.scanner.isEnd) {\n      this.error('Extra content at the end of the document');\n    }\n  }\n\n  /**\n  Adds the given `XmlNode` as a child of `this.currentNode`.\n   @param {XmlNode} node\n  */\n  _createClass(Parser, [{\n    key: \"addNode\",\n    value: function addNode(node) {\n      node.parent = this.currentNode;\n\n      // @ts-ignore\n      this.currentNode.children.push(node);\n    }\n    /**\n    Adds the given _text_ to the document, either by appending it to a preceding\n    `XmlText` node (if possible) or by creating a new `XmlText` node.\n     @param {string} text\n    */\n  }, {\n    key: \"addText\",\n    value: function addText(text) {\n      var children = this.currentNode.children;\n      if (children.length > 0) {\n        var prevNode = children[children.length - 1];\n        if (prevNode instanceof XmlText) {\n          // The previous node is a text node, so we can append to it and avoid\n          // creating another node.\n          prevNode.text += text;\n          return;\n        }\n      }\n      this.addNode(new XmlText(text));\n    }\n    /**\n    Consumes an `AttValue` (attribute value) if possible.\n     @returns {string|false}\n      Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\n      An empty string indicates that an `AttValue` was consumed but was empty.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n    */\n  }, {\n    key: \"consumeAttributeValue\",\n    value: function consumeAttributeValue() {\n      var scanner = this.scanner;\n      var quote = scanner.peek();\n      if (quote !== '\"' && quote !== \"'\") {\n        return false;\n      }\n      scanner.advance();\n      var chars;\n      var isClosed = false;\n      var value = emptyString;\n      var regex = quote === '\"' ? new RegExp(\"[^\\\"&<]+\", \"y\") : new RegExp(\"[^'&<]+\", \"y\");\n      matchLoop: while (!scanner.isEnd) {\n        chars = scanner.consumeMatch(regex);\n        if (chars) {\n          this.validateChars(chars);\n          value += chars.replace(/[\\t\\r\\n]/g, ' ');\n        }\n        var nextChar = scanner.peek();\n        switch (nextChar) {\n          case quote:\n            isClosed = true;\n            break matchLoop;\n          case '&':\n            value += this.consumeReference();\n            continue;\n          case '<':\n            this.error('Unescaped `<` is not allowed in an attribute value'); /* istanbul ignore next */\n            break;\n          case emptyString:\n            this.error('Unclosed attribute'); /* istanbul ignore next */\n            break;\n        }\n      }\n      if (!isClosed) {\n        this.error('Unclosed attribute');\n      }\n      scanner.advance();\n      return value;\n    }\n    /**\n    Consumes a CDATA section if possible.\n     @returns {boolean}\n      Whether a CDATA section was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n    */\n  }, {\n    key: \"consumeCdataSection\",\n    value: function consumeCdataSection() {\n      var scanner = this.scanner;\n      if (!scanner.consumeStringFast('<![CDATA[')) {\n        return false;\n      }\n      var text = scanner.consumeUntilString(']]>');\n      this.validateChars(text);\n      if (!scanner.consumeStringFast(']]>')) {\n        this.error('Unclosed CDATA section');\n      }\n      if (this.options.preserveCdata) {\n        this.addNode(new XmlCdata(text));\n      } else {\n        this.addText(text);\n      }\n      return true;\n    }\n    /**\n    Consumes character data if possible.\n     @returns {boolean}\n      Whether character data was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n    */\n  }, {\n    key: \"consumeCharData\",\n    value: function consumeCharData() {\n      var scanner = this.scanner;\n      var charData = scanner.consumeUntilMatch(/<|&|]]>/g);\n      if (!charData) {\n        return false;\n      }\n      this.validateChars(charData);\n      if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\n        this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n      }\n      this.addText(charData);\n      return true;\n    }\n    /**\n    Consumes a comment if possible.\n     @returns {boolean}\n      Whether a comment was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n    */\n  }, {\n    key: \"consumeComment\",\n    value: function consumeComment() {\n      var scanner = this.scanner;\n      if (!scanner.consumeStringFast('<!--')) {\n        return false;\n      }\n      var content = scanner.consumeUntilString('--');\n      this.validateChars(content);\n      if (!scanner.consumeStringFast('-->')) {\n        if (scanner.peek(2) === '--') {\n          this.error(\"The string `--` isn't allowed inside a comment\");\n        } else {\n          this.error('Unclosed comment');\n        }\n      }\n      if (this.options.preserveComments) {\n        this.addNode(new XmlComment(content.trim()));\n      }\n      return true;\n    }\n    /**\n    Consumes a reference in a content context if possible.\n     This differs from `consumeReference()` in that a consumed reference will be\n    added to the document as a text node instead of returned.\n     @returns {boolean}\n      Whether a reference was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n    */\n  }, {\n    key: \"consumeContentReference\",\n    value: function consumeContentReference() {\n      var ref = this.consumeReference();\n      if (ref) {\n        this.addText(ref);\n        return true;\n      }\n      return false;\n    }\n    /**\n    Consumes a doctype declaration if possible.\n     This is a loose implementation since doctype declarations are currently\n    discarded without further parsing.\n     @returns {boolean}\n      Whether a doctype declaration was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n    */\n  }, {\n    key: \"consumeDoctypeDeclaration\",\n    value: function consumeDoctypeDeclaration() {\n      var scanner = this.scanner;\n      if (!scanner.consumeStringFast('<!DOCTYPE') || !this.consumeWhitespace()) {\n        return false;\n      }\n      scanner.consumeMatch(new RegExp(\"[^[>]+\", \"y\"));\n      if (scanner.consumeMatch(new RegExp(\"\\\\[[\\\\s\\\\S]+?\\\\][\\\\x20\\\\t\\\\r\\\\n]*>\", \"y\"))) {\n        return true;\n      }\n      if (!scanner.consumeStringFast('>')) {\n        this.error('Unclosed doctype declaration');\n      }\n      return true;\n    }\n    /**\n    Consumes an element if possible.\n     @returns {boolean}\n      Whether an element was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n    */\n  }, {\n    key: \"consumeElement\",\n    value: function consumeElement() {\n      var scanner = this.scanner;\n      var mark = scanner.charIndex;\n      if (scanner.peek() !== '<') {\n        return false;\n      }\n      scanner.advance();\n      var name = this.consumeName();\n      if (!name) {\n        scanner.reset(mark);\n        return false;\n      }\n      var attributes = Object.create(null);\n      while (this.consumeWhitespace()) {\n        var attrName = this.consumeName();\n        if (!attrName) {\n          continue;\n        }\n        var attrValue = this.consumeEqual() && this.consumeAttributeValue();\n        if (attrValue === false) {\n          this.error('Attribute value expected');\n        }\n        if (attrName in attributes) {\n          this.error(\"Duplicate attribute: \".concat(attrName));\n        }\n        if (attrName === 'xml:space' && attrValue !== 'default' && attrValue !== 'preserve') {\n          this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n        }\n        attributes[attrName] = attrValue;\n      }\n      if (this.options.sortAttributes) {\n        var attrNames = Object.keys(attributes).sort();\n        var sortedAttributes = Object.create(null);\n        for (var i = 0; i < attrNames.length; ++i) {\n          var _attrName = attrNames[i];\n          sortedAttributes[_attrName] = attributes[_attrName];\n        }\n        attributes = sortedAttributes;\n      }\n      var isEmpty = Boolean(scanner.consumeStringFast('/>'));\n      var element = new XmlElement(name, attributes);\n      element.parent = this.currentNode;\n      if (!isEmpty) {\n        if (!scanner.consumeStringFast('>')) {\n          this.error(\"Unclosed start tag for element `\".concat(name, \"`\"));\n        }\n        this.currentNode = element;\n        this.consumeCharData();\n        while (this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment()) {\n          this.consumeCharData();\n        }\n        var endTagMark = scanner.charIndex;\n        var endTagName;\n        if (!scanner.consumeStringFast('</') || !(endTagName = this.consumeName()) || endTagName !== name) {\n          scanner.reset(endTagMark);\n          this.error(\"Missing end tag for element \".concat(name));\n        }\n        this.consumeWhitespace();\n        if (!scanner.consumeStringFast('>')) {\n          this.error(\"Unclosed end tag for element \".concat(name));\n        }\n        this.currentNode = element.parent;\n      }\n      this.addNode(element);\n      return true;\n    }\n    /**\n    Consumes an `Eq` production if possible.\n     @returns {boolean}\n      Whether an `Eq` production was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n    */\n  }, {\n    key: \"consumeEqual\",\n    value: function consumeEqual() {\n      this.consumeWhitespace();\n      if (this.scanner.consumeStringFast('=')) {\n        this.consumeWhitespace();\n        return true;\n      }\n      return false;\n    }\n    /**\n    Consumes `Misc` content if possible.\n     @returns {boolean}\n      Whether anything was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n    */\n  }, {\n    key: \"consumeMisc\",\n    value: function consumeMisc() {\n      return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();\n    }\n    /**\n    Consumes one or more `Name` characters if possible.\n     @returns {string}\n      `Name` characters, or an empty string if none were consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n    */\n  }, {\n    key: \"consumeName\",\n    value: function consumeName() {\n      return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;\n    }\n    /**\n    Consumes a processing instruction if possible.\n     @returns {boolean}\n      Whether a processing instruction was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n    */\n  }, {\n    key: \"consumeProcessingInstruction\",\n    value: function consumeProcessingInstruction() {\n      var scanner = this.scanner;\n      var mark = scanner.charIndex;\n      if (!scanner.consumeStringFast('<?')) {\n        return false;\n      }\n      var name = this.consumeName();\n      if (name) {\n        if (name.toLowerCase() === 'xml') {\n          scanner.reset(mark);\n          this.error(\"XML declaration isn't allowed here\");\n        }\n      } else {\n        this.error('Invalid processing instruction');\n      }\n      if (!this.consumeWhitespace()) {\n        if (scanner.consumeStringFast('?>')) {\n          this.addNode(new XmlProcessingInstruction(name));\n          return true;\n        }\n        this.error('Whitespace is required after a processing instruction name');\n      }\n      var content = scanner.consumeUntilString('?>');\n      this.validateChars(content);\n      if (!scanner.consumeStringFast('?>')) {\n        this.error('Unterminated processing instruction');\n      }\n      this.addNode(new XmlProcessingInstruction(name, content));\n      return true;\n    }\n    /**\n    Consumes a prolog if possible.\n     @returns {boolean}\n      Whether a prolog was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n    */\n  }, {\n    key: \"consumeProlog\",\n    value: function consumeProlog() {\n      var scanner = this.scanner;\n      var mark = scanner.charIndex;\n      this.consumeXmlDeclaration();\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n      if (this.consumeDoctypeDeclaration()) {\n        while (this.consumeMisc()) {} // eslint-disable-line no-empty\n      }\n\n      return mark < scanner.charIndex;\n    }\n    /**\n    Consumes a reference if possible.\n     This differs from `consumeContentReference()` in that a consumed reference\n    will be returned rather than added to the document.\n     @returns {string|false}\n      Parsed reference value, or `false` if nothing was consumed (to distinguish\n      from a reference that resolves to an empty string).\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n    */\n  }, {\n    key: \"consumeReference\",\n    value: function consumeReference() {\n      var scanner = this.scanner;\n      if (scanner.peek() !== '&') {\n        return false;\n      }\n      scanner.advance();\n      var ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n      if (scanner.consume() !== ';') {\n        this.error('Unterminated reference (a reference must end with `;`)');\n      }\n      var parsedValue;\n      if (ref[0] === '#') {\n        // This is a character reference.\n        var codePoint = ref[1] === 'x' ? parseInt(ref.slice(2), 16) // Hex codepoint.\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n        if (isNaN(codePoint)) {\n          this.error('Invalid character reference');\n        }\n        parsedValue = String.fromCodePoint(codePoint);\n        if (!syntax.isXmlChar(parsedValue)) {\n          this.error('Character reference resolves to an invalid character');\n        }\n      } else {\n        // This is an entity reference.\n        parsedValue = syntax.predefinedEntities[ref];\n        if (parsedValue === undefined) {\n          var _this$options = this.options,\n            ignoreUndefinedEntities = _this$options.ignoreUndefinedEntities,\n            resolveUndefinedEntity = _this$options.resolveUndefinedEntity;\n          var wrappedRef = \"&\".concat(ref, \";\"); // for backcompat with <= 2.x\n\n          if (resolveUndefinedEntity) {\n            var resolvedValue = resolveUndefinedEntity(wrappedRef);\n            if (resolvedValue !== null && resolvedValue !== undefined) {\n              var type = typeof resolvedValue;\n              if (type !== 'string') {\n                throw new TypeError(\"`resolveUndefinedEntity()` must return a string, `null`, or `undefined`, but returned a value of type \".concat(type));\n              }\n              return resolvedValue;\n            }\n          }\n          if (ignoreUndefinedEntities) {\n            return wrappedRef;\n          }\n          scanner.reset(-wrappedRef.length);\n          this.error(\"Named entity isn't defined: \".concat(wrappedRef));\n        }\n      }\n      return parsedValue;\n    }\n    /**\n    Consumes a `SystemLiteral` if possible.\n     A `SystemLiteral` is similar to an attribute value, but allows the characters\n    `<` and `&` and doesn't replace references.\n     @returns {string|false}\n      Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n      consumed. An empty string indicates that a `SystemLiteral` was consumed but\n      was empty.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n    */\n  }, {\n    key: \"consumeSystemLiteral\",\n    value: function consumeSystemLiteral() {\n      var scanner = this.scanner;\n      var quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n      if (!quote) {\n        return false;\n      }\n      var value = scanner.consumeUntilString(quote);\n      this.validateChars(value);\n      if (!scanner.consumeStringFast(quote)) {\n        this.error('Missing end quote');\n      }\n      return value;\n    }\n    /**\n    Consumes one or more whitespace characters if possible.\n     @returns {boolean}\n      Whether any whitespace characters were consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n    */\n  }, {\n    key: \"consumeWhitespace\",\n    value: function consumeWhitespace() {\n      return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n    }\n    /**\n    Consumes an XML declaration if possible.\n     @returns {boolean}\n      Whether an XML declaration was consumed.\n     @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n    */\n  }, {\n    key: \"consumeXmlDeclaration\",\n    value: function consumeXmlDeclaration() {\n      var scanner = this.scanner;\n      if (!scanner.consumeStringFast('<?xml')) {\n        return false;\n      }\n      if (!this.consumeWhitespace()) {\n        this.error('Invalid XML declaration');\n      }\n      var version = Boolean(scanner.consumeStringFast('version')) && this.consumeEqual() && this.consumeSystemLiteral();\n      if (version === false) {\n        this.error('XML version is missing or invalid');\n      } else if (!/^1\\.[0-9]+$/.test(version)) {\n        this.error('Invalid character in version number');\n      }\n      if (this.consumeWhitespace()) {\n        var encoding = Boolean(scanner.consumeStringFast('encoding')) && this.consumeEqual() && this.consumeSystemLiteral();\n        if (encoding) {\n          this.consumeWhitespace();\n        }\n        var standalone = Boolean(scanner.consumeStringFast('standalone')) && this.consumeEqual() && this.consumeSystemLiteral();\n        if (standalone) {\n          if (standalone !== 'yes' && standalone !== 'no') {\n            this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n          }\n          this.consumeWhitespace();\n        }\n      }\n      if (!scanner.consumeStringFast('?>')) {\n        this.error('Invalid or unclosed XML declaration');\n      }\n      return true;\n    }\n    /**\n    Throws an error at the current scanner position.\n     @param {string} message\n    */\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      var _this$scanner = this.scanner,\n        charIndex = _this$scanner.charIndex,\n        xml = _this$scanner.string;\n      var column = 1;\n      var excerpt = '';\n      var line = 1;\n\n      // Find the line and column where the error occurred.\n      for (var i = 0; i < charIndex; ++i) {\n        var char = xml[i];\n        if (char === '\\n') {\n          column = 1;\n          excerpt = '';\n          line += 1;\n        } else {\n          column += 1;\n          excerpt += char;\n        }\n      }\n      var eol = xml.indexOf('\\n', charIndex);\n      excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);\n      var excerptStart = 0;\n\n      // Keep the excerpt below 50 chars, but always keep the error position in\n      // view.\n      if (excerpt.length > 50) {\n        if (column < 40) {\n          excerpt = excerpt.slice(0, 50);\n        } else {\n          excerptStart = column - 20;\n          excerpt = excerpt.slice(excerptStart, column + 30);\n        }\n      }\n      var err = new Error(\"\".concat(message, \" (line \").concat(line, \", column \").concat(column, \")\\n\") + \"  \".concat(excerpt, \"\\n\") + ' '.repeat(column - excerptStart + 1) + '^\\n');\n      Object.assign(err, {\n        column: column,\n        excerpt: excerpt,\n        line: line,\n        pos: charIndex\n      });\n      throw err;\n    }\n    /**\n    Throws an invalid character error if any character in the given _string_ isn't\n    a valid XML character.\n     @param {string} string\n    */\n  }, {\n    key: \"validateChars\",\n    value: function validateChars(string) {\n      var charIndex = 0;\n      var _iterator = _createForOfIteratorHelper(string),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var char = _step.value;\n          if (syntax.isNotXmlChar(char)) {\n            this.scanner.reset(-(_toConsumableArray(string).length - charIndex));\n            this.error('Invalid character');\n          }\n          charIndex += 1;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n  return Parser;\n}();\nmodule.exports = Parser;\n\n// -- Private Functions --------------------------------------------------------\n\n/**\nNormalizes the given XML string by stripping a byte order mark (if present) and\nreplacing CRLF sequences and lone CR characters with LF characters.\n\n@param {string} xml\n@returns {string}\n*/\nfunction normalizeXmlString(xml) {\n  if (xml[0] === \"\\uFEFF\") {\n    xml = xml.slice(1);\n  }\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n\n/** @typedef {import('./XmlNode')} XmlNode */","map":null,"metadata":{},"sourceType":"script"}