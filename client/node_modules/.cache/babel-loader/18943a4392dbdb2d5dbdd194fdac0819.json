{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport React, { useEffect } from 'react';\nimport clsx from 'clsx';\nimport { MESSAGE_ACTIONS } from '../Message';\nimport { MessageInput, MessageInputFlat, MessageInputSmall } from '../MessageInput';\nimport { MessageList, VirtualizedMessageList } from '../MessageList';\nimport { ThreadHeader as DefaultThreadHeader } from './ThreadHeader';\nimport { ThreadHead as DefaultThreadHead } from '../Thread/ThreadHead';\nimport { useChannelActionContext, useChannelStateContext, useChatContext, useComponentContext } from '../../context';\n/**\n * The Thread component renders a parent Message with a list of replies\n */\nexport var Thread = function Thread(props) {\n  var _a = useChannelStateContext('Thread'),\n    channel = _a.channel,\n    channelConfig = _a.channelConfig,\n    thread = _a.thread;\n  if (!thread || (channelConfig === null || channelConfig === void 0 ? void 0 : channelConfig.replies) === false) return null;\n  // The wrapper ensures a key variable is set and the component recreates on thread switch\n  return React.createElement(ThreadInner, __assign({}, props, {\n    key: \"thread-\".concat(thread.id, \"-\").concat(channel === null || channel === void 0 ? void 0 : channel.cid)\n  }));\n};\nvar ThreadInner = function ThreadInner(props) {\n  var _a, _b;\n  var additionalMessageInputProps = props.additionalMessageInputProps,\n    additionalMessageListProps = props.additionalMessageListProps,\n    additionalParentMessageProps = props.additionalParentMessageProps,\n    additionalVirtualizedMessageListProps = props.additionalVirtualizedMessageListProps,\n    _c = props.autoFocus,\n    autoFocus = _c === void 0 ? true : _c,\n    _d = props.enableDateSeparator,\n    enableDateSeparator = _d === void 0 ? false : _d,\n    _e = props.fullWidth,\n    fullWidth = _e === void 0 ? false : _e,\n    PropInput = props.Input,\n    PropMessage = props.Message,\n    _f = props.messageActions,\n    messageActions = _f === void 0 ? Object.keys(MESSAGE_ACTIONS) : _f,\n    virtualized = props.virtualized;\n  var _g = useChannelStateContext('Thread'),\n    thread = _g.thread,\n    threadHasMore = _g.threadHasMore,\n    threadLoadingMore = _g.threadLoadingMore,\n    threadMessages = _g.threadMessages,\n    threadSuppressAutoscroll = _g.threadSuppressAutoscroll;\n  var _h = useChannelActionContext('Thread'),\n    closeThread = _h.closeThread,\n    loadMoreThread = _h.loadMoreThread;\n  var _j = useChatContext('Thread'),\n    customClasses = _j.customClasses,\n    themeVersion = _j.themeVersion;\n  var _k = useComponentContext('Thread'),\n    ContextInput = _k.ThreadInput,\n    ContextMessage = _k.Message,\n    _l = _k.ThreadHead,\n    ThreadHead = _l === void 0 ? DefaultThreadHead : _l,\n    _m = _k.ThreadHeader,\n    ThreadHeader = _m === void 0 ? DefaultThreadHeader : _m,\n    VirtualMessage = _k.VirtualMessage;\n  var ThreadInput = (_b = (_a = PropInput !== null && PropInput !== void 0 ? PropInput : additionalMessageInputProps === null || additionalMessageInputProps === void 0 ? void 0 : additionalMessageInputProps.Input) !== null && _a !== void 0 ? _a : ContextInput) !== null && _b !== void 0 ? _b : themeVersion === '2' ? MessageInputFlat : MessageInputSmall;\n  var ThreadMessage = PropMessage || (additionalMessageListProps === null || additionalMessageListProps === void 0 ? void 0 : additionalMessageListProps.Message);\n  var FallbackMessage = virtualized && VirtualMessage ? VirtualMessage : ContextMessage;\n  var MessageUIComponent = ThreadMessage || FallbackMessage;\n  var ThreadMessageList = virtualized ? VirtualizedMessageList : MessageList;\n  useEffect(function () {\n    if ((thread === null || thread === void 0 ? void 0 : thread.id) && (thread === null || thread === void 0 ? void 0 : thread.reply_count)) {\n      loadMoreThread();\n    }\n  }, []);\n  if (!thread) return null;\n  var threadClass = (customClasses === null || customClasses === void 0 ? void 0 : customClasses.thread) || clsx('str-chat__thread-container str-chat__thread', {\n    'str-chat__thread--full': fullWidth,\n    'str-chat__thread--virtualized': virtualized\n  });\n  var head = React.createElement(ThreadHead, __assign({\n    key: thread.id,\n    message: thread,\n    Message: MessageUIComponent\n  }, additionalParentMessageProps));\n  return React.createElement(\"div\", {\n    className: threadClass\n  }, React.createElement(ThreadHeader, {\n    closeThread: closeThread,\n    thread: thread\n  }), React.createElement(ThreadMessageList, __assign({\n    disableDateSeparator: !enableDateSeparator,\n    hasMore: threadHasMore,\n    head: head,\n    loadingMore: threadLoadingMore,\n    loadMore: loadMoreThread,\n    Message: MessageUIComponent,\n    messageActions: messageActions,\n    messages: threadMessages || [],\n    suppressAutoscroll: threadSuppressAutoscroll,\n    threadList: true\n  }, virtualized ? additionalVirtualizedMessageListProps : additionalMessageListProps)), React.createElement(MessageInput, __assign({\n    focus: autoFocus,\n    Input: ThreadInput,\n    parent: thread,\n    publishTypingEvent: false\n  }, additionalMessageInputProps)));\n};","map":null,"metadata":{},"sourceType":"module"}