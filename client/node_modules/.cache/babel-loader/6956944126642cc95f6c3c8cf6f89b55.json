{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport deepequal from 'react-fast-compare';\n/**\n * Following function validates a function which returns notification message.\n * It validates if the first parameter is function and also if return value of function is string or no.\n */\nexport var validateAndGetMessage = function validateAndGetMessage(func, args) {\n  if (!func || typeof func !== 'function') return null;\n  // below is due to tests passing a single argument\n  // rather than an array.\n  if (!(args instanceof Array)) {\n    // @ts-expect-error\n    args = [args];\n  }\n  var returnValue = func.apply(void 0, args);\n  if (typeof returnValue !== 'string') return null;\n  return returnValue;\n};\n/**\n * Tell if the owner of the current message is muted\n */\nexport var isUserMuted = function isUserMuted(message, mutes) {\n  if (!mutes || !message) return false;\n  var userMuted = mutes.filter(function (el) {\n    var _a;\n    return el.target.id === ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id);\n  });\n  return !!userMuted.length;\n};\nexport var MESSAGE_ACTIONS = {\n  delete: 'delete',\n  edit: 'edit',\n  flag: 'flag',\n  mute: 'mute',\n  pin: 'pin',\n  quote: 'quote',\n  react: 'react',\n  reply: 'reply'\n};\n// @deprecated in favor of `channelCapabilities` - TODO: remove in next major release\nexport var defaultPinPermissions = {\n  commerce: {\n    admin: true,\n    anonymous: false,\n    channel_member: false,\n    channel_moderator: true,\n    guest: false,\n    member: false,\n    moderator: true,\n    owner: true,\n    user: false\n  },\n  gaming: {\n    admin: true,\n    anonymous: false,\n    channel_member: false,\n    channel_moderator: true,\n    guest: false,\n    member: false,\n    moderator: true,\n    owner: false,\n    user: false\n  },\n  livestream: {\n    admin: true,\n    anonymous: false,\n    channel_member: false,\n    channel_moderator: true,\n    guest: false,\n    member: false,\n    moderator: true,\n    owner: true,\n    user: false\n  },\n  messaging: {\n    admin: true,\n    anonymous: false,\n    channel_member: true,\n    channel_moderator: true,\n    guest: false,\n    member: true,\n    moderator: true,\n    owner: true,\n    user: false\n  },\n  team: {\n    admin: true,\n    anonymous: false,\n    channel_member: true,\n    channel_moderator: true,\n    guest: false,\n    member: true,\n    moderator: true,\n    owner: true,\n    user: false\n  }\n};\nexport var getMessageActions = function getMessageActions(actions, _a) {\n  var canDelete = _a.canDelete,\n    canEdit = _a.canEdit,\n    canFlag = _a.canFlag,\n    canMute = _a.canMute,\n    canPin = _a.canPin,\n    canQuote = _a.canQuote,\n    canReact = _a.canReact,\n    canReply = _a.canReply;\n  var messageActionsAfterPermission = [];\n  var messageActions = [];\n  if (actions && typeof actions === 'boolean') {\n    // If value of actions is true, then populate all the possible values\n    messageActions = Object.keys(MESSAGE_ACTIONS);\n  } else if (actions && actions.length > 0) {\n    messageActions = __spreadArray([], actions, true);\n  } else {\n    return [];\n  }\n  if (canDelete && messageActions.indexOf(MESSAGE_ACTIONS.delete) > -1) {\n    messageActionsAfterPermission.push(MESSAGE_ACTIONS.delete);\n  }\n  if (canEdit && messageActions.indexOf(MESSAGE_ACTIONS.edit) > -1) {\n    messageActionsAfterPermission.push(MESSAGE_ACTIONS.edit);\n  }\n  if (canFlag && messageActions.indexOf(MESSAGE_ACTIONS.flag) > -1) {\n    messageActionsAfterPermission.push(MESSAGE_ACTIONS.flag);\n  }\n  if (canMute && messageActions.indexOf(MESSAGE_ACTIONS.mute) > -1) {\n    messageActionsAfterPermission.push(MESSAGE_ACTIONS.mute);\n  }\n  if (canPin && messageActions.indexOf(MESSAGE_ACTIONS.pin) > -1) {\n    messageActionsAfterPermission.push(MESSAGE_ACTIONS.pin);\n  }\n  if (canQuote && messageActions.indexOf(MESSAGE_ACTIONS.quote) > -1) {\n    messageActionsAfterPermission.push(MESSAGE_ACTIONS.quote);\n  }\n  if (canReact && messageActions.indexOf(MESSAGE_ACTIONS.react) > -1) {\n    messageActionsAfterPermission.push(MESSAGE_ACTIONS.react);\n  }\n  if (canReply && messageActions.indexOf(MESSAGE_ACTIONS.reply) > -1) {\n    messageActionsAfterPermission.push(MESSAGE_ACTIONS.reply);\n  }\n  return messageActionsAfterPermission;\n};\nvar ACTIONS_NOT_WORKING_IN_THREAD = ['pin', 'react', 'reply'];\nexport var showMessageActionsBox = function showMessageActionsBox(actions, inThread) {\n  if (actions.length === 0) {\n    return false;\n  }\n  if (inThread && actions.filter(function (action) {\n    return !ACTIONS_NOT_WORKING_IN_THREAD.includes(action);\n  }).length === 0) {\n    return false;\n  }\n  if (actions.length === 1 && (actions.includes('react') || actions.includes('reply'))) {\n    return false;\n  }\n  if (actions.length === 2 && actions.includes('react') && actions.includes('reply')) {\n    return false;\n  }\n  return true;\n};\nvar areMessagesEqual = function areMessagesEqual(prevMessage, nextMessage) {\n  var _a, _b, _c, _d, _e, _f;\n  return prevMessage.deleted_at === nextMessage.deleted_at && ((_a = prevMessage.latest_reactions) === null || _a === void 0 ? void 0 : _a.length) === ((_b = nextMessage.latest_reactions) === null || _b === void 0 ? void 0 : _b.length) && ((_c = prevMessage.own_reactions) === null || _c === void 0 ? void 0 : _c.length) === ((_d = nextMessage.own_reactions) === null || _d === void 0 ? void 0 : _d.length) && prevMessage.pinned === nextMessage.pinned && prevMessage.reply_count === nextMessage.reply_count && prevMessage.status === nextMessage.status && prevMessage.text === nextMessage.text && prevMessage.type === nextMessage.type && prevMessage.updated_at === nextMessage.updated_at && ((_e = prevMessage.user) === null || _e === void 0 ? void 0 : _e.updated_at) === ((_f = nextMessage.user) === null || _f === void 0 ? void 0 : _f.updated_at);\n};\nexport var areMessagePropsEqual = function areMessagePropsEqual(prevProps, nextProps) {\n  var prevMessage = prevProps.message,\n    prevMessageUI = prevProps.Message;\n  var nextMessage = nextProps.message,\n    nextMessageUI = nextProps.Message;\n  if (prevMessageUI !== nextMessageUI) return false;\n  if (prevProps.endOfGroup !== nextProps.endOfGroup) return false;\n  if (nextProps.showDetailedReactions !== prevProps.showDetailedReactions) {\n    return false;\n  }\n  var messagesAreEqual = areMessagesEqual(prevMessage, nextMessage);\n  if (!messagesAreEqual) return false;\n  var deepEqualProps = deepequal(nextProps.messageActions, prevProps.messageActions) && deepequal(nextProps.readBy, prevProps.readBy) && deepequal(nextProps.highlighted, prevProps.highlighted) && deepequal(nextProps.groupStyles, prevProps.groupStyles) &&\n  // last 3 messages can have different group styles\n  deepequal(nextProps.mutes, prevProps.mutes) && deepequal(nextProps.lastReceivedId, prevProps.lastReceivedId);\n  if (!deepEqualProps) return false;\n  return prevProps.messageListRect === nextProps.messageListRect // MessageList wrapper layout changes\n  ;\n};\n\nexport var areMessageUIPropsEqual = function areMessageUIPropsEqual(prevProps, nextProps) {\n  var _a, _b, _c, _d;\n  var prevLastReceivedId = prevProps.lastReceivedId,\n    prevMessage = prevProps.message;\n  var nextLastReceivedId = nextProps.lastReceivedId,\n    nextMessage = nextProps.message;\n  if (prevProps.editing !== nextProps.editing) return false;\n  if (prevProps.highlighted !== nextProps.highlighted) return false;\n  if (prevProps.endOfGroup !== nextProps.endOfGroup) return false;\n  if (((_a = prevProps.mutes) === null || _a === void 0 ? void 0 : _a.length) !== ((_b = nextProps.mutes) === null || _b === void 0 ? void 0 : _b.length)) return false;\n  if (((_c = prevProps.readBy) === null || _c === void 0 ? void 0 : _c.length) !== ((_d = nextProps.readBy) === null || _d === void 0 ? void 0 : _d.length)) return false;\n  if (prevProps.showDetailedReactions !== nextProps.showDetailedReactions) {\n    return false;\n  }\n  if ((prevMessage.id === prevLastReceivedId || prevMessage.id === nextLastReceivedId) && prevLastReceivedId !== nextLastReceivedId) {\n    return false;\n  }\n  return areMessagesEqual(prevMessage, nextMessage);\n};\nexport var messageHasReactions = function messageHasReactions(message) {\n  return !!(message === null || message === void 0 ? void 0 : message.latest_reactions) && !!message.latest_reactions.length;\n};\nexport var messageHasAttachments = function messageHasAttachments(message) {\n  return !!(message === null || message === void 0 ? void 0 : message.attachments) && !!message.attachments.length;\n};\nexport var getImages = function getImages(message) {\n  if (!(message === null || message === void 0 ? void 0 : message.attachments)) {\n    return [];\n  }\n  return message.attachments.filter(function (item) {\n    return item.type === 'image';\n  });\n};\nexport var getNonImageAttachments = function getNonImageAttachments(message) {\n  if (!(message === null || message === void 0 ? void 0 : message.attachments)) {\n    return [];\n  }\n  return message.attachments.filter(function (item) {\n    return item.type !== 'image';\n  });\n};\n/**\n * Default Tooltip Username mapper implementation.\n *\n * @param user the user.\n */\nexport var mapToUserNameOrId = function mapToUserNameOrId(user) {\n  return user.name || user.id;\n};\nexport var getReadByTooltipText = function getReadByTooltipText(users, t, client, tooltipUserNameMapper) {\n  var outStr = '';\n  if (!t) {\n    throw new Error('getReadByTooltipText was called, but translation function is not available');\n  }\n  if (!tooltipUserNameMapper) {\n    throw new Error('getReadByTooltipText was called, but tooltipUserNameMapper function is not available');\n  }\n  // first filter out client user, so restLength won't count it\n  var otherUsers = users.filter(function (item) {\n    return item && (client === null || client === void 0 ? void 0 : client.user) && item.id !== client.user.id;\n  }).map(tooltipUserNameMapper);\n  var slicedArr = otherUsers.slice(0, 5);\n  var restLength = otherUsers.length - slicedArr.length;\n  if (slicedArr.length === 1) {\n    outStr = \"\".concat(slicedArr[0], \" \");\n  } else if (slicedArr.length === 2) {\n    // joins all with \"and\" but =no commas\n    // example: \"bob and sam\"\n    outStr = t('{{ firstUser }} and {{ secondUser }}', {\n      firstUser: slicedArr[0],\n      secondUser: slicedArr[1]\n    });\n  } else if (slicedArr.length > 2) {\n    // joins all with commas, but last one gets \", and\" (oxford comma!)\n    // example: \"bob, joe, sam and 4 more\"\n    if (restLength === 0) {\n      // mutate slicedArr to remove last user to display it separately\n      var lastUser = slicedArr.splice(slicedArr.length - 1, 1);\n      outStr = t('{{ commaSeparatedUsers }}, and {{ lastUser }}', {\n        commaSeparatedUsers: slicedArr.join(', '),\n        lastUser: lastUser\n      });\n    } else {\n      outStr = t('{{ commaSeparatedUsers }} and {{ moreCount }} more', {\n        commaSeparatedUsers: slicedArr.join(', '),\n        moreCount: restLength\n      });\n    }\n  }\n  return outStr;\n};","map":null,"metadata":{},"sourceType":"module"}