{"ast":null,"code":"import { systemToComponent as t } from \"@virtuoso.dev/react-urx\";\nimport * as e from \"@virtuoso.dev/urx\";\nimport * as n from \"react\";\nimport { useLayoutEffect as o, useEffect as r, useRef as i, useCallback as a, createElement as l, useContext as s } from \"react\";\nimport { flushSync as u } from \"react-dom\";\nfunction c() {\n  return c = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);\n    }\n    return t;\n  }, c.apply(this, arguments);\n}\nfunction m(t, e) {\n  if (null == t) return {};\n  var n,\n    o,\n    r = {},\n    i = Object.keys(t);\n  for (o = 0; o < i.length; o++) e.indexOf(n = i[o]) >= 0 || (r[n] = t[n]);\n  return r;\n}\nfunction d(t, e) {\n  (null == e || e > t.length) && (e = t.length);\n  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];\n  return o;\n}\nfunction f(t, e) {\n  var n = \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n  if (n) return (n = n.call(t)).next.bind(n);\n  if (Array.isArray(t) || (n = function (t, e) {\n    if (t) {\n      if (\"string\" == typeof t) return d(t, e);\n      var n = Object.prototype.toString.call(t).slice(8, -1);\n      return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? d(t, e) : void 0;\n    }\n  }(t)) || e && t && \"number\" == typeof t.length) {\n    n && (t = n);\n    var o = 0;\n    return function () {\n      return o >= t.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: t[o++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar p,\n  h,\n  g = \"undefined\" != typeof document ? o : r;\n!function (t) {\n  t[t.DEBUG = 0] = \"DEBUG\", t[t.INFO = 1] = \"INFO\", t[t.WARN = 2] = \"WARN\", t[t.ERROR = 3] = \"ERROR\";\n}(h || (h = {}));\nvar v = ((p = {})[h.DEBUG] = \"debug\", p[h.INFO] = \"log\", p[h.WARN] = \"warn\", p[h.ERROR] = \"error\", p),\n  S = e.system(function () {\n    var t = e.statefulStream(h.ERROR);\n    return {\n      log: e.statefulStream(function (n, o, r) {\n        var i;\n        void 0 === r && (r = h.INFO), r >= (null != (i = (\"undefined\" == typeof globalThis ? window : globalThis).VIRTUOSO_LOG_LEVEL) ? i : e.getValue(t)) && console[v[r]](\"%creact-virtuoso: %c%s %o\", \"color: #0253b3; font-weight: bold\", \"color: initial\", n, o);\n      }),\n      logLevel: t\n    };\n  }, [], {\n    singleton: !0\n  });\nfunction I(t, e) {\n  void 0 === e && (e = !0);\n  var n = i(null),\n    o = function o(t) {};\n  if (\"undefined\" != typeof ResizeObserver) {\n    var r = new ResizeObserver(function (e) {\n      var n = e[0].target;\n      null !== n.offsetParent && t(n);\n    });\n    o = function o(t) {\n      t && e ? (r.observe(t), n.current = t) : (n.current && r.unobserve(n.current), n.current = null);\n    };\n  }\n  return {\n    ref: n,\n    callbackRef: o\n  };\n}\nfunction C(t, e) {\n  return void 0 === e && (e = !0), I(t, e).callbackRef;\n}\nfunction T(t, e, n, o, r, i, a) {\n  return I(function (n) {\n    for (var l = function (t, e, n, o) {\n        var r = t.length;\n        if (0 === r) return null;\n        for (var i = [], a = 0; a < r; a++) {\n          var l = t.item(a);\n          if (l && void 0 !== l.dataset.index) {\n            var s = parseInt(l.dataset.index),\n              u = parseFloat(l.dataset.knownSize),\n              c = e(l, \"offsetHeight\");\n            if (0 === c && o(\"Zero-sized element, this should not happen\", {\n              child: l\n            }, h.ERROR), c !== u) {\n              var m = i[i.length - 1];\n              0 === i.length || m.size !== c || m.endIndex !== s - 1 ? i.push({\n                startIndex: s,\n                endIndex: s,\n                size: c\n              }) : i[i.length - 1].endIndex++;\n            }\n          }\n        }\n        return i;\n      }(n.children, e, 0, r), s = n.parentElement; !s.dataset.virtuosoScroller;) s = s.parentElement;\n    var u = \"window\" === s.firstElementChild.dataset.viewportType,\n      c = a ? a.scrollTop : u ? window.pageYOffset || document.documentElement.scrollTop : s.scrollTop,\n      m = a ? a.scrollHeight : u ? document.documentElement.scrollHeight : s.scrollHeight,\n      d = a ? a.offsetHeight : u ? window.innerHeight : s.offsetHeight;\n    o({\n      scrollTop: Math.max(c, 0),\n      scrollHeight: m,\n      viewportHeight: d\n    }), null == i || i(function (t, e, n) {\n      return \"normal\" === e || null != e && e.endsWith(\"px\") || n(\"row-gap was not resolved to pixel value correctly\", e, h.WARN), \"normal\" === e ? 0 : parseInt(null != e ? e : \"0\", 10);\n    }(0, getComputedStyle(n).rowGap, r)), null !== l && t(l);\n  }, n);\n}\nfunction w(t, e) {\n  return Math.round(t.getBoundingClientRect()[e]);\n}\nfunction x(t, e) {\n  return Math.abs(t - e) < 1.01;\n}\nfunction b(t, n, o, l, s) {\n  void 0 === l && (l = e.noop);\n  var c = i(null),\n    m = i(null),\n    d = i(null),\n    f = i(!1),\n    p = a(function (e) {\n      var o = e.target,\n        r = o === window || o === document,\n        i = r ? window.pageYOffset || document.documentElement.scrollTop : o.scrollTop,\n        a = r ? document.documentElement.scrollHeight : o.scrollHeight,\n        l = r ? window.innerHeight : o.offsetHeight,\n        s = function s() {\n          t({\n            scrollTop: Math.max(i, 0),\n            scrollHeight: a,\n            viewportHeight: l\n          });\n        };\n      f.current ? u(s) : s(), f.current = !1, null !== m.current && (i === m.current || i <= 0 || i === a - l) && (m.current = null, n(!0), d.current && (clearTimeout(d.current), d.current = null));\n    }, [t, n]);\n  return r(function () {\n    var t = s || c.current;\n    return l(s || c.current), p({\n      target: t\n    }), t.addEventListener(\"scroll\", p, {\n      passive: !0\n    }), function () {\n      l(null), t.removeEventListener(\"scroll\", p);\n    };\n  }, [c, p, o, l, s]), {\n    scrollerRef: c,\n    scrollByCallback: function scrollByCallback(t) {\n      f.current = !0, c.current.scrollBy(t);\n    },\n    scrollToCallback: function scrollToCallback(e) {\n      var o = c.current;\n      if (o && (!(\"offsetHeight\" in o) || 0 !== o.offsetHeight)) {\n        var r,\n          i,\n          a,\n          l = \"smooth\" === e.behavior;\n        if (o === window ? (i = Math.max(w(document.documentElement, \"height\"), document.documentElement.scrollHeight), r = window.innerHeight, a = document.documentElement.scrollTop) : (i = o.scrollHeight, r = w(o, \"height\"), a = o.scrollTop), e.top = Math.ceil(Math.max(Math.min(i - r, e.top), 0)), x(r, i) || e.top === a) return t({\n          scrollTop: a,\n          scrollHeight: i,\n          viewportHeight: r\n        }), void (l && n(!0));\n        l ? (m.current = e.top, d.current && clearTimeout(d.current), d.current = setTimeout(function () {\n          d.current = null, m.current = null, n(!0);\n        }, 1e3)) : m.current = null, o.scrollTo(e);\n      }\n    }\n  };\n}\nvar y = e.system(function () {\n    var t = e.stream(),\n      n = e.stream(),\n      o = e.statefulStream(0),\n      r = e.stream(),\n      i = e.statefulStream(0),\n      a = e.stream(),\n      l = e.stream(),\n      s = e.statefulStream(0),\n      u = e.statefulStream(0),\n      c = e.statefulStream(0),\n      m = e.statefulStream(0),\n      d = e.stream(),\n      f = e.stream(),\n      p = e.statefulStream(!1),\n      h = e.statefulStream(!1);\n    return e.connect(e.pipe(t, e.map(function (t) {\n      return t.scrollTop;\n    })), n), e.connect(e.pipe(t, e.map(function (t) {\n      return t.scrollHeight;\n    })), l), e.connect(n, i), {\n      scrollContainerState: t,\n      scrollTop: n,\n      viewportHeight: a,\n      headerHeight: s,\n      fixedHeaderHeight: u,\n      fixedFooterHeight: c,\n      footerHeight: m,\n      scrollHeight: l,\n      smoothScrollTargetReached: r,\n      react18ConcurrentRendering: h,\n      scrollTo: d,\n      scrollBy: f,\n      statefulScrollTop: i,\n      deviation: o,\n      scrollingInProgress: p\n    };\n  }, [], {\n    singleton: !0\n  }),\n  H = {\n    lvl: 0\n  };\nfunction E(t, e, n, o, r) {\n  return void 0 === o && (o = H), void 0 === r && (r = H), {\n    k: t,\n    v: e,\n    lvl: n,\n    l: o,\n    r: r\n  };\n}\nfunction R(t) {\n  return t === H;\n}\nfunction L() {\n  return H;\n}\nfunction k(t, e) {\n  if (R(t)) return H;\n  var n = t.k,\n    o = t.l,\n    r = t.r;\n  if (e === n) {\n    if (R(o)) return r;\n    if (R(r)) return o;\n    var i = O(o);\n    return A(V(t, {\n      k: i[0],\n      v: i[1],\n      l: M(o)\n    }));\n  }\n  return A(V(t, e < n ? {\n    l: k(o, e)\n  } : {\n    r: k(r, e)\n  }));\n}\nfunction F(t, e, n) {\n  if (void 0 === n && (n = \"k\"), R(t)) return [-Infinity, void 0];\n  if (t[n] === e) return [t.k, t.v];\n  if (t[n] < e) {\n    var o = F(t.r, e, n);\n    return -Infinity === o[0] ? [t.k, t.v] : o;\n  }\n  return F(t.l, e, n);\n}\nfunction z(t, e, n) {\n  return R(t) ? E(e, n, 1) : e === t.k ? V(t, {\n    k: e,\n    v: n\n  }) : function (t) {\n    return D(G(t));\n  }(V(t, e < t.k ? {\n    l: z(t.l, e, n)\n  } : {\n    r: z(t.r, e, n)\n  }));\n}\nfunction B(t, e, n) {\n  if (R(t)) return [];\n  var o = t.k,\n    r = t.v,\n    i = t.r,\n    a = [];\n  return o > e && (a = a.concat(B(t.l, e, n))), o >= e && o <= n && a.push({\n    k: o,\n    v: r\n  }), o <= n && (a = a.concat(B(i, e, n))), a;\n}\nfunction P(t) {\n  return R(t) ? [] : [].concat(P(t.l), [{\n    k: t.k,\n    v: t.v\n  }], P(t.r));\n}\nfunction O(t) {\n  return R(t.r) ? [t.k, t.v] : O(t.r);\n}\nfunction M(t) {\n  return R(t.r) ? t.l : A(V(t, {\n    r: M(t.r)\n  }));\n}\nfunction V(t, e) {\n  return E(void 0 !== e.k ? e.k : t.k, void 0 !== e.v ? e.v : t.v, void 0 !== e.lvl ? e.lvl : t.lvl, void 0 !== e.l ? e.l : t.l, void 0 !== e.r ? e.r : t.r);\n}\nfunction U(t) {\n  return R(t) || t.lvl > t.r.lvl;\n}\nfunction A(t) {\n  var e = t.l,\n    n = t.r,\n    o = t.lvl;\n  if (n.lvl >= o - 1 && e.lvl >= o - 1) return t;\n  if (o > n.lvl + 1) {\n    if (U(e)) return G(V(t, {\n      lvl: o - 1\n    }));\n    if (R(e) || R(e.r)) throw new Error(\"Unexpected empty nodes\");\n    return V(e.r, {\n      l: V(e, {\n        r: e.r.l\n      }),\n      r: V(t, {\n        l: e.r.r,\n        lvl: o - 1\n      }),\n      lvl: o\n    });\n  }\n  if (U(t)) return D(V(t, {\n    lvl: o - 1\n  }));\n  if (R(n) || R(n.l)) throw new Error(\"Unexpected empty nodes\");\n  var r = n.l,\n    i = U(r) ? n.lvl - 1 : n.lvl;\n  return V(r, {\n    l: V(t, {\n      r: r.l,\n      lvl: o - 1\n    }),\n    r: D(V(n, {\n      l: r.r,\n      lvl: i\n    })),\n    lvl: r.lvl + 1\n  });\n}\nfunction W(t, e, n) {\n  return R(t) ? [] : N(B(t, F(t, e)[0], n), function (t) {\n    return {\n      index: t.k,\n      value: t.v\n    };\n  });\n}\nfunction N(t, e) {\n  var n = t.length;\n  if (0 === n) return [];\n  for (var o = e(t[0]), r = o.index, i = o.value, a = [], l = 1; l < n; l++) {\n    var s = e(t[l]),\n      u = s.index,\n      c = s.value;\n    a.push({\n      start: r,\n      end: u - 1,\n      value: i\n    }), r = u, i = c;\n  }\n  return a.push({\n    start: r,\n    end: Infinity,\n    value: i\n  }), a;\n}\nfunction D(t) {\n  var e = t.r,\n    n = t.lvl;\n  return R(e) || R(e.r) || e.lvl !== n || e.r.lvl !== n ? t : V(e, {\n    l: V(t, {\n      r: e.l\n    }),\n    lvl: n + 1\n  });\n}\nfunction G(t) {\n  var e = t.l;\n  return R(e) || e.lvl !== t.lvl ? t : V(e, {\n    r: V(t, {\n      l: e.r\n    })\n  });\n}\nfunction _(t, e, n, o) {\n  void 0 === o && (o = 0);\n  for (var r = t.length - 1; o <= r;) {\n    var i = Math.floor((o + r) / 2),\n      a = n(t[i], e);\n    if (0 === a) return i;\n    if (-1 === a) {\n      if (r - o < 2) return i - 1;\n      r = i - 1;\n    } else {\n      if (r === o) return i;\n      o = i + 1;\n    }\n  }\n  throw new Error(\"Failed binary finding record in array - \" + t.join(\",\") + \", searched for \" + e);\n}\nfunction j(t, e, n) {\n  return t[_(t, e, n)];\n}\nvar K = e.system(function () {\n  return {\n    recalcInProgress: e.statefulStream(!1)\n  };\n}, [], {\n  singleton: !0\n});\nfunction Y(t) {\n  var e = t.size,\n    n = t.startIndex,\n    o = t.endIndex;\n  return function (t) {\n    return t.start === n && (t.end === o || Infinity === t.end) && t.value === e;\n  };\n}\nfunction q(t, e) {\n  var n = t.index;\n  return e === n ? 0 : e < n ? -1 : 1;\n}\nfunction Z(t, e) {\n  var n = t.offset;\n  return e === n ? 0 : e < n ? -1 : 1;\n}\nfunction J(t) {\n  return {\n    index: t.index,\n    value: t\n  };\n}\nfunction $(t, e, n, o) {\n  var r = t,\n    i = 0,\n    a = 0,\n    l = 0,\n    s = 0;\n  if (0 !== e) {\n    l = r[s = _(r, e - 1, q)].offset;\n    var u = F(n, e - 1);\n    i = u[0], a = u[1], r.length && r[s].size === F(n, e)[1] && (s -= 1), r = r.slice(0, s + 1);\n  } else r = [];\n  for (var c, m = f(W(n, e, Infinity)); !(c = m()).done;) {\n    var d = c.value,\n      p = d.start,\n      h = d.value,\n      g = p - i,\n      v = g * a + l + g * o;\n    r.push({\n      offset: v,\n      size: h,\n      index: p\n    }), i = p, l = v, a = h;\n  }\n  return {\n    offsetTree: r,\n    lastIndex: i,\n    lastOffset: l,\n    lastSize: a\n  };\n}\nfunction Q(t, e) {\n  var n = e[0],\n    o = e[1],\n    r = e[3];\n  n.length > 0 && (0, e[2])(\"received item sizes\", n, h.DEBUG);\n  var i = t.sizeTree,\n    a = i,\n    l = 0;\n  if (o.length > 0 && R(i) && 2 === n.length) {\n    var s = n[0].size,\n      u = n[1].size;\n    a = o.reduce(function (t, e) {\n      return z(z(t, e, s), e + 1, u);\n    }, a);\n  } else {\n    var c = function (t, e) {\n      for (var n, o = R(t) ? 0 : Infinity, r = f(e); !(n = r()).done;) {\n        var i = n.value,\n          a = i.size,\n          l = i.startIndex,\n          s = i.endIndex;\n        if (o = Math.min(o, l), R(t)) t = z(t, 0, a);else {\n          var u = W(t, l - 1, s + 1);\n          if (!u.some(Y(i))) {\n            for (var c, m = !1, d = !1, p = f(u); !(c = p()).done;) {\n              var h = c.value,\n                g = h.start,\n                v = h.end,\n                S = h.value;\n              m ? (s >= g || a === S) && (t = k(t, g)) : (d = S !== a, m = !0), v > s && s >= g && S !== a && (t = z(t, s + 1, S));\n            }\n            d && (t = z(t, l, a));\n          }\n        }\n      }\n      return [t, o];\n    }(a, n);\n    a = c[0], l = c[1];\n  }\n  if (a === i) return t;\n  var m = $(t.offsetTree, l, a, r),\n    d = m.offsetTree;\n  return {\n    sizeTree: a,\n    offsetTree: d,\n    lastIndex: m.lastIndex,\n    lastOffset: m.lastOffset,\n    lastSize: m.lastSize,\n    groupOffsetTree: o.reduce(function (t, e) {\n      return z(t, e, X(e, d, r));\n    }, L()),\n    groupIndices: o\n  };\n}\nfunction X(t, e, n) {\n  if (0 === e.length) return 0;\n  var o = j(e, t, q),\n    r = t - o.index,\n    i = o.size * r + (r - 1) * n + o.offset;\n  return i > 0 ? i + n : i;\n}\nfunction tt(t, e, n) {\n  if (function (t) {\n    return void 0 !== t.groupIndex;\n  }(t)) return e.groupIndices[t.groupIndex] + 1;\n  var o = et(\"LAST\" === t.index ? n : t.index, e);\n  return Math.max(0, o, Math.min(n, o));\n}\nfunction et(t, e) {\n  if (!nt(e)) return t;\n  for (var n = 0; e.groupIndices[n] <= t + n;) n++;\n  return t + n;\n}\nfunction nt(t) {\n  return !R(t.groupOffsetTree);\n}\nvar ot = {\n    offsetHeight: \"height\",\n    offsetWidth: \"width\"\n  },\n  rt = e.system(function (t) {\n    var n = t[0].log,\n      o = t[1].recalcInProgress,\n      r = e.stream(),\n      i = e.stream(),\n      a = e.statefulStreamFromEmitter(i, 0),\n      l = e.stream(),\n      s = e.stream(),\n      u = e.statefulStream(0),\n      m = e.statefulStream([]),\n      d = e.statefulStream(void 0),\n      f = e.statefulStream(void 0),\n      p = e.statefulStream(function (t, e) {\n        return w(t, ot[e]);\n      }),\n      g = e.statefulStream(void 0),\n      v = e.statefulStream(0),\n      S = {\n        offsetTree: [],\n        sizeTree: L(),\n        groupOffsetTree: L(),\n        lastIndex: 0,\n        lastOffset: 0,\n        lastSize: 0,\n        groupIndices: []\n      },\n      I = e.statefulStreamFromEmitter(e.pipe(r, e.withLatestFrom(m, n, v), e.scan(Q, S), e.distinctUntilChanged()), S);\n    e.connect(e.pipe(m, e.filter(function (t) {\n      return t.length > 0;\n    }), e.withLatestFrom(I, v), e.map(function (t) {\n      var e = t[0],\n        n = t[1],\n        o = t[2],\n        r = e.reduce(function (t, e, r) {\n          return z(t, e, X(e, n.offsetTree, o) || r);\n        }, L());\n      return c({}, n, {\n        groupIndices: e,\n        groupOffsetTree: r\n      });\n    })), I), e.connect(e.pipe(i, e.withLatestFrom(I), e.filter(function (t) {\n      return t[0] < t[1].lastIndex;\n    }), e.map(function (t) {\n      var e = t[1];\n      return [{\n        startIndex: t[0],\n        endIndex: e.lastIndex,\n        size: e.lastSize\n      }];\n    })), r), e.connect(d, f);\n    var C = e.statefulStreamFromEmitter(e.pipe(d, e.map(function (t) {\n      return void 0 === t;\n    })), !0);\n    e.connect(e.pipe(f, e.filter(function (t) {\n      return void 0 !== t && R(e.getValue(I).sizeTree);\n    }), e.map(function (t) {\n      return [{\n        startIndex: 0,\n        endIndex: 0,\n        size: t\n      }];\n    })), r);\n    var T = e.streamFromEmitter(e.pipe(r, e.withLatestFrom(I), e.scan(function (t, e) {\n      var n = e[1];\n      return {\n        changed: n !== t.sizes,\n        sizes: n\n      };\n    }, {\n      changed: !1,\n      sizes: S\n    }), e.map(function (t) {\n      return t.changed;\n    })));\n    e.subscribe(e.pipe(u, e.scan(function (t, e) {\n      return {\n        diff: t.prev - e,\n        prev: e\n      };\n    }, {\n      diff: 0,\n      prev: 0\n    }), e.map(function (t) {\n      return t.diff;\n    })), function (t) {\n      t > 0 ? (e.publish(o, !0), e.publish(l, t)) : t < 0 && e.publish(s, t);\n    }), e.subscribe(e.pipe(u, e.withLatestFrom(n)), function (t) {\n      t[0] < 0 && (0, t[1])(\"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\", {\n        firstItemIndex: u\n      }, h.ERROR);\n    });\n    var x = e.streamFromEmitter(l);\n    e.connect(e.pipe(l, e.withLatestFrom(I), e.map(function (t) {\n      var e = t[0],\n        n = t[1];\n      if (n.groupIndices.length > 0) throw new Error(\"Virtuoso: prepending items does not work with groups\");\n      return P(n.sizeTree).reduce(function (t, n) {\n        var o = n.k,\n          r = n.v;\n        return {\n          ranges: [].concat(t.ranges, [{\n            startIndex: t.prevIndex,\n            endIndex: o + e - 1,\n            size: t.prevSize\n          }]),\n          prevIndex: o + e,\n          prevSize: r\n        };\n      }, {\n        ranges: [],\n        prevIndex: 0,\n        prevSize: n.lastSize\n      }).ranges;\n    })), r);\n    var b = e.streamFromEmitter(e.pipe(s, e.withLatestFrom(I, v), e.map(function (t) {\n      return X(-t[0], t[1].offsetTree, t[2]);\n    })));\n    return e.connect(e.pipe(s, e.withLatestFrom(I, v), e.map(function (t) {\n      var e = t[0],\n        n = t[1],\n        o = t[2];\n      if (n.groupIndices.length > 0) throw new Error(\"Virtuoso: shifting items does not work with groups\");\n      var r = P(n.sizeTree).reduce(function (t, n) {\n        var o = n.v;\n        return z(t, Math.max(0, n.k + e), o);\n      }, L());\n      return c({}, n, {\n        sizeTree: r\n      }, $(n.offsetTree, 0, r, o));\n    })), I), {\n      data: g,\n      totalCount: i,\n      sizeRanges: r,\n      groupIndices: m,\n      defaultItemSize: f,\n      fixedItemSize: d,\n      unshiftWith: l,\n      shiftWith: s,\n      shiftWithOffset: b,\n      beforeUnshiftWith: x,\n      firstItemIndex: u,\n      gap: v,\n      sizes: I,\n      listRefresh: T,\n      statefulTotalCount: a,\n      trackItemSizes: C,\n      itemSize: p\n    };\n  }, e.tup(S, K), {\n    singleton: !0\n  }),\n  it = \"undefined\" != typeof document && \"scrollBehavior\" in document.documentElement.style;\nfunction at(t) {\n  var e = \"number\" == typeof t ? {\n    index: t\n  } : t;\n  return e.align || (e.align = \"start\"), e.behavior && it || (e.behavior = \"auto\"), e.offset || (e.offset = 0), e;\n}\nvar lt = e.system(function (t) {\n    var n = t[0],\n      o = n.sizes,\n      r = n.totalCount,\n      i = n.listRefresh,\n      a = n.gap,\n      l = t[1],\n      s = l.scrollingInProgress,\n      u = l.viewportHeight,\n      c = l.scrollTo,\n      m = l.smoothScrollTargetReached,\n      d = l.headerHeight,\n      f = l.footerHeight,\n      p = l.fixedHeaderHeight,\n      g = l.fixedFooterHeight,\n      v = t[2].log,\n      S = e.stream(),\n      I = e.statefulStream(0),\n      C = null,\n      T = null,\n      w = null;\n    function x() {\n      C && (C(), C = null), w && (w(), w = null), T && (clearTimeout(T), T = null), e.publish(s, !1);\n    }\n    return e.connect(e.pipe(S, e.withLatestFrom(o, u, r, I, d, f, v), e.withLatestFrom(a, p, g), e.map(function (t) {\n      var n = t[0],\n        o = n[0],\n        r = n[1],\n        a = n[2],\n        l = n[3],\n        u = n[4],\n        c = n[5],\n        d = n[6],\n        f = n[7],\n        p = t[1],\n        g = t[2],\n        v = t[3],\n        I = at(o),\n        b = I.align,\n        y = I.behavior,\n        H = I.offset,\n        E = l - 1,\n        R = tt(I, r, E),\n        L = X(R, r.offsetTree, p) + c;\n      \"end\" === b ? (L += g + F(r.sizeTree, R)[1] - a + v, R === E && (L += d)) : \"center\" === b ? L += (g + F(r.sizeTree, R)[1] - a + v) / 2 : L -= u, H && (L += H);\n      var k = function k(t) {\n        x(), t ? (f(\"retrying to scroll to\", {\n          location: o\n        }, h.DEBUG), e.publish(S, o)) : f(\"list did not change, scroll successful\", {}, h.DEBUG);\n      };\n      if (x(), \"smooth\" === y) {\n        var z = !1;\n        w = e.subscribe(i, function (t) {\n          z = z || t;\n        }), C = e.handleNext(m, function () {\n          k(z);\n        });\n      } else C = e.handleNext(e.pipe(i, function (t) {\n        var e = setTimeout(function () {\n          t(!1);\n        }, 150);\n        return function (n) {\n          n && (t(!0), clearTimeout(e));\n        };\n      }), k);\n      return T = setTimeout(function () {\n        x();\n      }, 1200), e.publish(s, !0), f(\"scrolling from index to\", {\n        index: R,\n        top: L,\n        behavior: y\n      }, h.DEBUG), {\n        top: L,\n        behavior: y\n      };\n    })), c), {\n      scrollToIndex: S,\n      topListHeight: I\n    };\n  }, e.tup(rt, y, S), {\n    singleton: !0\n  }),\n  st = \"up\",\n  ut = {\n    atBottom: !1,\n    notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n    state: {\n      offsetBottom: 0,\n      scrollTop: 0,\n      viewportHeight: 0,\n      scrollHeight: 0\n    }\n  },\n  ct = e.system(function (t) {\n    var n = t[0],\n      o = n.scrollContainerState,\n      r = n.scrollTop,\n      i = n.viewportHeight,\n      a = n.headerHeight,\n      l = n.footerHeight,\n      s = n.scrollBy,\n      u = e.statefulStream(!1),\n      c = e.statefulStream(!0),\n      m = e.stream(),\n      d = e.stream(),\n      f = e.statefulStream(4),\n      p = e.statefulStream(0),\n      h = e.statefulStreamFromEmitter(e.pipe(e.merge(e.pipe(e.duc(r), e.skip(1), e.mapTo(!0)), e.pipe(e.duc(r), e.skip(1), e.mapTo(!1), e.debounceTime(100))), e.distinctUntilChanged()), !1),\n      g = e.statefulStreamFromEmitter(e.pipe(e.merge(e.pipe(s, e.mapTo(!0)), e.pipe(s, e.mapTo(!1), e.debounceTime(200))), e.distinctUntilChanged()), !1);\n    e.connect(e.pipe(e.combineLatest(e.duc(r), e.duc(p)), e.map(function (t) {\n      return t[0] <= t[1];\n    }), e.distinctUntilChanged()), c), e.connect(e.pipe(c, e.throttleTime(50)), d);\n    var v = e.streamFromEmitter(e.pipe(e.combineLatest(o, e.duc(i), e.duc(a), e.duc(l), e.duc(f)), e.scan(function (t, e) {\n        var n,\n          o,\n          r = e[0],\n          i = r.scrollTop,\n          a = r.scrollHeight,\n          l = e[1],\n          s = {\n            viewportHeight: l,\n            scrollTop: i,\n            scrollHeight: a\n          };\n        return i + l - a > -e[4] ? (i > t.state.scrollTop ? (n = \"SCROLLED_DOWN\", o = t.state.scrollTop - i) : (n = \"SIZE_DECREASED\", o = t.state.scrollTop - i || t.scrollTopDelta), {\n          atBottom: !0,\n          state: s,\n          atBottomBecause: n,\n          scrollTopDelta: o\n        }) : {\n          atBottom: !1,\n          notAtBottomBecause: s.scrollHeight > t.state.scrollHeight ? \"SIZE_INCREASED\" : l < t.state.viewportHeight ? \"VIEWPORT_HEIGHT_DECREASING\" : i < t.state.scrollTop ? \"SCROLLING_UPWARDS\" : \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\",\n          state: s\n        };\n      }, ut), e.distinctUntilChanged(function (t, e) {\n        return t && t.atBottom === e.atBottom;\n      }))),\n      S = e.statefulStreamFromEmitter(e.pipe(o, e.scan(function (t, e) {\n        var n = e.scrollTop,\n          o = e.scrollHeight,\n          r = e.viewportHeight;\n        return x(t.scrollHeight, o) ? {\n          scrollTop: n,\n          scrollHeight: o,\n          jump: 0,\n          changed: !1\n        } : t.scrollTop !== n && o - (n + r) < 1 ? {\n          scrollHeight: o,\n          scrollTop: n,\n          jump: t.scrollTop - n,\n          changed: !0\n        } : {\n          scrollHeight: o,\n          scrollTop: n,\n          jump: 0,\n          changed: !0\n        };\n      }, {\n        scrollHeight: 0,\n        jump: 0,\n        scrollTop: 0,\n        changed: !1\n      }), e.filter(function (t) {\n        return t.changed;\n      }), e.map(function (t) {\n        return t.jump;\n      })), 0);\n    e.connect(e.pipe(v, e.map(function (t) {\n      return t.atBottom;\n    })), u), e.connect(e.pipe(u, e.throttleTime(50)), m);\n    var I = e.statefulStream(\"down\");\n    e.connect(e.pipe(o, e.map(function (t) {\n      return t.scrollTop;\n    }), e.distinctUntilChanged(), e.scan(function (t, n) {\n      return e.getValue(g) ? {\n        direction: t.direction,\n        prevScrollTop: n\n      } : {\n        direction: n < t.prevScrollTop ? st : \"down\",\n        prevScrollTop: n\n      };\n    }, {\n      direction: \"down\",\n      prevScrollTop: 0\n    }), e.map(function (t) {\n      return t.direction;\n    })), I), e.connect(e.pipe(o, e.throttleTime(50), e.mapTo(\"none\")), I);\n    var C = e.statefulStream(0);\n    return e.connect(e.pipe(h, e.filter(function (t) {\n      return !t;\n    }), e.mapTo(0)), C), e.connect(e.pipe(r, e.throttleTime(100), e.withLatestFrom(h), e.filter(function (t) {\n      return !!t[1];\n    }), e.scan(function (t, e) {\n      return [t[1], e[0]];\n    }, [0, 0]), e.map(function (t) {\n      return t[1] - t[0];\n    })), C), {\n      isScrolling: h,\n      isAtTop: c,\n      isAtBottom: u,\n      atBottomState: v,\n      atTopStateChange: d,\n      atBottomStateChange: m,\n      scrollDirection: I,\n      atBottomThreshold: f,\n      atTopThreshold: p,\n      scrollVelocity: C,\n      lastJumpDueToItemResize: S\n    };\n  }, e.tup(y)),\n  mt = e.system(function (t) {\n    var n = t[0].log,\n      o = e.statefulStream(!1),\n      r = e.streamFromEmitter(e.pipe(o, e.filter(function (t) {\n        return t;\n      }), e.distinctUntilChanged()));\n    return e.subscribe(o, function (t) {\n      t && e.getValue(n)(\"props updated\", {}, h.DEBUG);\n    }), {\n      propsReady: o,\n      didMount: r\n    };\n  }, e.tup(S), {\n    singleton: !0\n  }),\n  dt = e.system(function (t) {\n    var n = t[0],\n      o = n.sizes,\n      r = n.listRefresh,\n      i = n.defaultItemSize,\n      a = t[1].scrollTop,\n      l = t[2].scrollToIndex,\n      s = t[3].didMount,\n      u = e.statefulStream(!0),\n      c = e.statefulStream(0);\n    return e.connect(e.pipe(s, e.withLatestFrom(c), e.filter(function (t) {\n      return !!t[1];\n    }), e.mapTo(!1)), u), e.subscribe(e.pipe(e.combineLatest(r, s), e.withLatestFrom(u, o, i), e.filter(function (t) {\n      var e = t[1],\n        n = t[3];\n      return t[0][1] && (!R(t[2].sizeTree) || void 0 !== n) && !e;\n    }), e.withLatestFrom(c)), function (t) {\n      var n = t[1];\n      setTimeout(function () {\n        e.handleNext(a, function () {\n          e.publish(u, !0);\n        }), e.publish(l, n);\n      });\n    }), {\n      scrolledToInitialItem: u,\n      initialTopMostItemIndex: c\n    };\n  }, e.tup(rt, y, lt, mt), {\n    singleton: !0\n  });\nfunction ft(t) {\n  return !!t && (\"smooth\" === t ? \"smooth\" : \"auto\");\n}\nvar pt = e.system(function (t) {\n  var n = t[0],\n    o = n.totalCount,\n    r = n.listRefresh,\n    i = t[1],\n    a = i.isAtBottom,\n    l = i.atBottomState,\n    s = t[2].scrollToIndex,\n    u = t[3].scrolledToInitialItem,\n    c = t[4],\n    m = c.propsReady,\n    d = c.didMount,\n    f = t[5].log,\n    p = t[6].scrollingInProgress,\n    g = e.statefulStream(!1),\n    v = e.stream(),\n    S = null;\n  function I(t) {\n    e.publish(s, {\n      index: \"LAST\",\n      align: \"end\",\n      behavior: t\n    });\n  }\n  function C(t) {\n    var n = e.handleNext(l, function (n) {\n      !t || n.atBottom || \"SIZE_INCREASED\" !== n.notAtBottomBecause || S || (e.getValue(f)(\"scrolling to bottom due to increased size\", {}, h.DEBUG), I(\"auto\"));\n    });\n    setTimeout(n, 100);\n  }\n  return e.subscribe(e.pipe(e.combineLatest(e.pipe(e.duc(o), e.skip(1)), d), e.withLatestFrom(e.duc(g), a, u, p), e.map(function (t) {\n    var e = t[0],\n      n = e[0],\n      o = e[1] && t[3],\n      r = \"auto\";\n    return o && (r = function (t, e) {\n      return \"function\" == typeof t ? ft(t(e)) : e && ft(t);\n    }(t[1], t[2] || t[4]), o = o && !!r), {\n      totalCount: n,\n      shouldFollow: o,\n      followOutputBehavior: r\n    };\n  }), e.filter(function (t) {\n    return t.shouldFollow;\n  })), function (t) {\n    var n = t.totalCount,\n      o = t.followOutputBehavior;\n    S && (S(), S = null), S = e.handleNext(r, function () {\n      e.getValue(f)(\"following output to \", {\n        totalCount: n\n      }, h.DEBUG), I(o), S = null;\n    });\n  }), e.subscribe(e.pipe(e.combineLatest(e.duc(g), o, m), e.filter(function (t) {\n    return t[0] && t[2];\n  }), e.scan(function (t, e) {\n    var n = e[1];\n    return {\n      refreshed: t.value === n,\n      value: n\n    };\n  }, {\n    refreshed: !1,\n    value: 0\n  }), e.filter(function (t) {\n    return t.refreshed;\n  }), e.withLatestFrom(g, o)), function (t) {\n    C(!1 !== t[1]);\n  }), e.subscribe(v, function () {\n    C(!1 !== e.getValue(g));\n  }), e.subscribe(e.combineLatest(e.duc(g), l), function (t) {\n    var e = t[1];\n    t[0] && !e.atBottom && \"VIEWPORT_HEIGHT_DECREASING\" === e.notAtBottomBecause && I(\"auto\");\n  }), {\n    followOutput: g,\n    autoscrollToBottom: v\n  };\n}, e.tup(rt, ct, lt, dt, mt, S, y));\nfunction ht(t) {\n  return t.reduce(function (t, e) {\n    return t.groupIndices.push(t.totalCount), t.totalCount += e + 1, t;\n  }, {\n    totalCount: 0,\n    groupIndices: []\n  });\n}\nvar gt = e.system(function (t) {\n  var n = t[0],\n    o = n.totalCount,\n    r = n.groupIndices,\n    i = n.sizes,\n    a = t[1],\n    l = a.scrollTop,\n    s = a.headerHeight,\n    u = e.stream(),\n    c = e.stream(),\n    m = e.streamFromEmitter(e.pipe(u, e.map(ht)));\n  return e.connect(e.pipe(m, e.map(function (t) {\n    return t.totalCount;\n  })), o), e.connect(e.pipe(m, e.map(function (t) {\n    return t.groupIndices;\n  })), r), e.connect(e.pipe(e.combineLatest(l, i, s), e.filter(function (t) {\n    return nt(t[1]);\n  }), e.map(function (t) {\n    return F(t[1].groupOffsetTree, Math.max(t[0] - t[2], 0), \"v\")[0];\n  }), e.distinctUntilChanged(), e.map(function (t) {\n    return [t];\n  })), c), {\n    groupCounts: u,\n    topItemsIndexes: c\n  };\n}, e.tup(rt, y));\nfunction vt(t, e) {\n  return !(!t || t[0] !== e[0] || t[1] !== e[1]);\n}\nfunction St(t, e) {\n  return !(!t || t.startIndex !== e.startIndex || t.endIndex !== e.endIndex);\n}\nfunction It(t, e, n) {\n  return \"number\" == typeof t ? n === st && \"top\" === e || \"down\" === n && \"bottom\" === e ? t : 0 : n === st ? \"top\" === e ? t.main : t.reverse : \"bottom\" === e ? t.main : t.reverse;\n}\nfunction Ct(t, e) {\n  return \"number\" == typeof t ? t : t[e] || 0;\n}\nvar Tt = e.system(function (t) {\n    var n = t[0],\n      o = n.scrollTop,\n      r = n.viewportHeight,\n      i = n.deviation,\n      a = n.headerHeight,\n      l = n.fixedHeaderHeight,\n      s = e.stream(),\n      u = e.statefulStream(0),\n      c = e.statefulStream(0),\n      m = e.statefulStream(0),\n      d = e.statefulStreamFromEmitter(e.pipe(e.combineLatest(e.duc(o), e.duc(r), e.duc(a), e.duc(s, vt), e.duc(m), e.duc(u), e.duc(l), e.duc(i), e.duc(c)), e.map(function (t) {\n        var e = t[0],\n          n = t[1],\n          o = t[2],\n          r = t[3],\n          i = r[0],\n          a = r[1],\n          l = t[4],\n          s = t[6],\n          u = t[7],\n          c = t[8],\n          m = e - u,\n          d = t[5] + s,\n          f = Math.max(o - m, 0),\n          p = \"none\",\n          h = Ct(c, \"top\"),\n          g = Ct(c, \"bottom\");\n        return i -= u, a += o + s, (i += o + s) > e + d - h && (p = st), (a -= u) < e - f + n + g && (p = \"down\"), \"none\" !== p ? [Math.max(m - o - It(l, \"top\", p) - h, 0), m - f - s + n + It(l, \"bottom\", p) + g] : null;\n      }), e.filter(function (t) {\n        return null != t;\n      }), e.distinctUntilChanged(vt)), [0, 0]);\n    return {\n      listBoundary: s,\n      overscan: m,\n      topListHeight: u,\n      increaseViewportBy: c,\n      visibleRange: d\n    };\n  }, e.tup(y), {\n    singleton: !0\n  }),\n  wt = {\n    items: [],\n    topItems: [],\n    offsetTop: 0,\n    offsetBottom: 0,\n    top: 0,\n    bottom: 0,\n    topListHeight: 0,\n    totalCount: 0,\n    firstItemIndex: 0\n  };\nfunction xt(t, e, n) {\n  if (0 === t.length) return [];\n  if (!nt(e)) return t.map(function (t) {\n    return c({}, t, {\n      index: t.index + n,\n      originalIndex: t.index\n    });\n  });\n  for (var o, r = [], i = W(e.groupOffsetTree, t[0].index, t[t.length - 1].index), a = void 0, l = 0, s = f(t); !(o = s()).done;) {\n    var u = o.value;\n    (!a || a.end < u.index) && (a = i.shift(), l = e.groupIndices.indexOf(a.start)), r.push(c({}, u.index === a.start ? {\n      type: \"group\",\n      index: l\n    } : {\n      index: u.index - (l + 1) + n,\n      groupIndex: l\n    }, {\n      size: u.size,\n      offset: u.offset,\n      originalIndex: u.index,\n      data: u.data\n    }));\n  }\n  return r;\n}\nfunction bt(t, e, n, o, r, i) {\n  var a = 0,\n    l = 0;\n  if (t.length > 0) {\n    a = t[0].offset;\n    var s = t[t.length - 1];\n    l = s.offset + s.size;\n  }\n  var u = n - r.lastIndex,\n    c = a,\n    m = r.lastOffset + u * r.lastSize + (u - 1) * o - l;\n  return {\n    items: xt(t, r, i),\n    topItems: xt(e, r, i),\n    topListHeight: e.reduce(function (t, e) {\n      return e.size + t;\n    }, 0),\n    offsetTop: a,\n    offsetBottom: m,\n    top: c,\n    bottom: l,\n    totalCount: n,\n    firstItemIndex: i\n  };\n}\nvar yt = e.system(function (t) {\n    var n = t[0],\n      o = n.sizes,\n      r = n.totalCount,\n      i = n.data,\n      a = n.firstItemIndex,\n      l = n.gap,\n      s = t[1],\n      u = t[2],\n      m = u.visibleRange,\n      d = u.listBoundary,\n      p = u.topListHeight,\n      h = t[3],\n      g = h.scrolledToInitialItem,\n      v = h.initialTopMostItemIndex,\n      S = t[4].topListHeight,\n      I = t[5],\n      C = t[6].didMount,\n      T = t[7].recalcInProgress,\n      w = e.statefulStream([]),\n      x = e.stream();\n    e.connect(s.topItemsIndexes, w);\n    var b = e.statefulStreamFromEmitter(e.pipe(e.combineLatest(C, T, e.duc(m, vt), e.duc(r), e.duc(o), e.duc(v), g, e.duc(w), e.duc(a), e.duc(l), i), e.filter(function (t) {\n      return t[0] && !t[1];\n    }), e.map(function (t) {\n      var n = t[2],\n        o = n[0],\n        r = n[1],\n        i = t[3],\n        a = t[5],\n        l = t[6],\n        s = t[7],\n        u = t[8],\n        m = t[9],\n        d = t[10],\n        p = t[4],\n        h = p.sizeTree,\n        g = p.offsetTree;\n      if (0 === i || 0 === o && 0 === r) return c({}, wt, {\n        totalCount: i\n      });\n      if (R(h)) return bt(function (t, e, n) {\n        if (nt(e)) {\n          var o = et(t, e);\n          return [{\n            index: F(e.groupOffsetTree, o)[0],\n            size: 0,\n            offset: 0\n          }, {\n            index: o,\n            size: 0,\n            offset: 0,\n            data: n && n[0]\n          }];\n        }\n        return [{\n          index: t,\n          size: 0,\n          offset: 0,\n          data: n && n[0]\n        }];\n      }(function (t, e) {\n        return \"number\" == typeof t ? t : \"LAST\" === t.index ? e - 1 : t.index;\n      }(a, i), p, d), [], i, m, p, u);\n      var v = [];\n      if (s.length > 0) for (var S, I = s[0], C = s[s.length - 1], T = 0, w = f(W(h, I, C)); !(S = w()).done;) for (var x = S.value, b = x.value, y = Math.max(x.start, I), H = Math.min(x.end, C), E = y; E <= H; E++) v.push({\n        index: E,\n        size: b,\n        offset: T,\n        data: d && d[E]\n      }), T += b;\n      if (!l) return bt([], v, i, m, p, u);\n      var L = s.length > 0 ? s[s.length - 1] + 1 : 0,\n        k = function (t, e, n, o) {\n          return void 0 === o && (o = 0), o > 0 && (e = Math.max(e, j(t, o, q).offset)), N((i = n, l = _(r = t, e, a = Z), s = _(r, i, a, l), r.slice(l, s + 1)), J);\n          var r, i, a, l, s;\n        }(g, o, r, L);\n      if (0 === k.length) return null;\n      var z = i - 1;\n      return bt(e.tap([], function (t) {\n        for (var e, n = f(k); !(e = n()).done;) {\n          var i = e.value,\n            a = i.value,\n            l = a.offset,\n            s = i.start,\n            u = a.size;\n          if (a.offset < o) {\n            var c = (s += Math.floor((o - a.offset + m) / (u + m))) - i.start;\n            l += c * u + c * m;\n          }\n          s < L && (l += (L - s) * u, s = L);\n          for (var p = Math.min(i.end, z), h = s; h <= p && !(l >= r); h++) t.push({\n            index: h,\n            size: u,\n            offset: l,\n            data: d && d[h]\n          }), l += u + m;\n        }\n      }), v, i, m, p, u);\n    }), e.filter(function (t) {\n      return null !== t;\n    }), e.distinctUntilChanged()), wt);\n    return e.connect(e.pipe(i, e.filter(function (t) {\n      return void 0 !== t;\n    }), e.map(function (t) {\n      return t.length;\n    })), r), e.connect(e.pipe(b, e.map(function (t) {\n      return t.topListHeight;\n    })), S), e.connect(S, p), e.connect(e.pipe(b, e.map(function (t) {\n      return [t.top, t.bottom];\n    })), d), e.connect(e.pipe(b, e.map(function (t) {\n      return t.items;\n    })), x), c({\n      listState: b,\n      topItemsIndexes: w,\n      endReached: e.streamFromEmitter(e.pipe(b, e.filter(function (t) {\n        return t.items.length > 0;\n      }), e.withLatestFrom(r, i), e.filter(function (t) {\n        var e = t[0].items;\n        return e[e.length - 1].originalIndex === t[1] - 1;\n      }), e.map(function (t) {\n        return [t[1] - 1, t[2]];\n      }), e.distinctUntilChanged(vt), e.map(function (t) {\n        return t[0];\n      }))),\n      startReached: e.streamFromEmitter(e.pipe(b, e.throttleTime(200), e.filter(function (t) {\n        var e = t.items;\n        return e.length > 0 && e[0].originalIndex === t.topItems.length;\n      }), e.map(function (t) {\n        return t.items[0].index;\n      }), e.distinctUntilChanged())),\n      rangeChanged: e.streamFromEmitter(e.pipe(b, e.filter(function (t) {\n        return t.items.length > 0;\n      }), e.map(function (t) {\n        for (var e = t.items, n = 0, o = e.length - 1; \"group\" === e[n].type && n < o;) n++;\n        for (; \"group\" === e[o].type && o > n;) o--;\n        return {\n          startIndex: e[n].index,\n          endIndex: e[o].index\n        };\n      }), e.distinctUntilChanged(St))),\n      itemsRendered: x\n    }, I);\n  }, e.tup(rt, gt, Tt, dt, lt, ct, mt, K), {\n    singleton: !0\n  }),\n  Ht = e.system(function (t) {\n    var n = t[0],\n      o = n.sizes,\n      r = n.firstItemIndex,\n      i = n.data,\n      a = n.gap,\n      l = t[1].listState,\n      s = t[2].didMount,\n      u = e.statefulStream(0);\n    return e.connect(e.pipe(s, e.withLatestFrom(u), e.filter(function (t) {\n      return 0 !== t[1];\n    }), e.withLatestFrom(o, r, a, i), e.map(function (t) {\n      var e = t[0][1],\n        n = t[1],\n        o = t[2],\n        r = t[3],\n        i = t[4],\n        a = void 0 === i ? [] : i,\n        l = 0;\n      if (n.groupIndices.length > 0) for (var s, u = f(n.groupIndices); !((s = u()).done || s.value - l >= e);) l++;\n      var c = e + l;\n      return bt(Array.from({\n        length: c\n      }).map(function (t, e) {\n        return {\n          index: e,\n          size: 0,\n          offset: 0,\n          data: a[e]\n        };\n      }), [], c, r, n, o);\n    })), l), {\n      initialItemCount: u\n    };\n  }, e.tup(rt, yt, mt), {\n    singleton: !0\n  }),\n  Et = e.system(function (t) {\n    var n = t[0].scrollVelocity,\n      o = e.statefulStream(!1),\n      r = e.stream(),\n      i = e.statefulStream(!1);\n    return e.connect(e.pipe(n, e.withLatestFrom(i, o, r), e.filter(function (t) {\n      return !!t[1];\n    }), e.map(function (t) {\n      var e = t[0],\n        n = t[1],\n        o = t[2],\n        r = t[3],\n        i = n.enter;\n      if (o) {\n        if ((0, n.exit)(e, r)) return !1;\n      } else if (i(e, r)) return !0;\n      return o;\n    }), e.distinctUntilChanged()), o), e.subscribe(e.pipe(e.combineLatest(o, n, r), e.withLatestFrom(i)), function (t) {\n      var e = t[0],\n        n = t[1];\n      return e[0] && n && n.change && n.change(e[1], e[2]);\n    }), {\n      isSeeking: o,\n      scrollSeekConfiguration: i,\n      scrollVelocity: n,\n      scrollSeekRangeChanged: r\n    };\n  }, e.tup(ct), {\n    singleton: !0\n  }),\n  Rt = e.system(function (t) {\n    var n = t[0].topItemsIndexes,\n      o = e.statefulStream(0);\n    return e.connect(e.pipe(o, e.filter(function (t) {\n      return t > 0;\n    }), e.map(function (t) {\n      return Array.from({\n        length: t\n      }).map(function (t, e) {\n        return e;\n      });\n    })), n), {\n      topItemCount: o\n    };\n  }, e.tup(yt)),\n  Lt = e.system(function (t) {\n    var n = t[0],\n      o = n.footerHeight,\n      r = n.headerHeight,\n      i = n.fixedHeaderHeight,\n      a = n.fixedFooterHeight,\n      l = t[1].listState,\n      s = e.stream(),\n      u = e.statefulStreamFromEmitter(e.pipe(e.combineLatest(o, a, r, i, l), e.map(function (t) {\n        var e = t[4];\n        return t[0] + t[1] + t[2] + t[3] + e.offsetBottom + e.bottom;\n      })), 0);\n    return e.connect(e.duc(u), s), {\n      totalListHeight: u,\n      totalListHeightChanged: s\n    };\n  }, e.tup(y, yt), {\n    singleton: !0\n  });\nfunction kt(t) {\n  var e,\n    n = !1;\n  return function () {\n    return n || (n = !0, e = t()), e;\n  };\n}\nvar Ft = kt(function () {\n    return /iP(ad|hone|od).+Version\\/[\\d.]+.*Safari/i.test(navigator.userAgent);\n  }),\n  zt = e.system(function (t) {\n    var n = t[0],\n      o = n.scrollBy,\n      r = n.scrollTop,\n      i = n.deviation,\n      a = n.scrollingInProgress,\n      l = t[1],\n      s = l.isScrolling,\n      u = l.isAtBottom,\n      c = l.scrollDirection,\n      m = t[3],\n      d = m.beforeUnshiftWith,\n      f = m.shiftWithOffset,\n      p = m.sizes,\n      g = m.gap,\n      v = t[4].log,\n      S = t[5].recalcInProgress,\n      I = e.streamFromEmitter(e.pipe(t[2].listState, e.withLatestFrom(l.lastJumpDueToItemResize), e.scan(function (t, e) {\n        var n = t[1],\n          o = e[0],\n          r = o.items,\n          i = o.totalCount,\n          a = o.bottom + o.offsetBottom,\n          l = 0;\n        return t[2] === i && n.length > 0 && r.length > 0 && (0 === r[0].originalIndex && 0 === n[0].originalIndex || 0 != (l = a - t[3]) && (l += e[1])), [l, r, i, a];\n      }, [0, [], 0, 0]), e.filter(function (t) {\n        return 0 !== t[0];\n      }), e.withLatestFrom(r, c, a, u, v), e.filter(function (t) {\n        return !t[3] && 0 !== t[1] && t[2] === st;\n      }), e.map(function (t) {\n        var e = t[0][0];\n        return (0, t[5])(\"Upward scrolling compensation\", {\n          amount: e\n        }, h.DEBUG), e;\n      })));\n    function C(t) {\n      t > 0 ? (e.publish(o, {\n        top: -t,\n        behavior: \"auto\"\n      }), e.publish(i, 0)) : (e.publish(i, 0), e.publish(o, {\n        top: -t,\n        behavior: \"auto\"\n      }));\n    }\n    return e.subscribe(e.pipe(I, e.withLatestFrom(i, s)), function (t) {\n      var n = t[0],\n        o = t[1];\n      t[2] && Ft() ? e.publish(i, o - n) : C(-n);\n    }), e.subscribe(e.pipe(e.combineLatest(e.statefulStreamFromEmitter(s, !1), i, S), e.filter(function (t) {\n      return !t[0] && !t[2] && 0 !== t[1];\n    }), e.map(function (t) {\n      return t[1];\n    }), e.throttleTime(1)), C), e.connect(e.pipe(f, e.map(function (t) {\n      return {\n        top: -t\n      };\n    })), o), e.subscribe(e.pipe(d, e.withLatestFrom(p, g), e.map(function (t) {\n      var e = t[0];\n      return e * t[1].lastSize + e * t[2];\n    })), function (t) {\n      e.publish(i, t), requestAnimationFrame(function () {\n        e.publish(o, {\n          top: t\n        }), requestAnimationFrame(function () {\n          e.publish(i, 0), e.publish(S, !1);\n        });\n      });\n    }), {\n      deviation: i\n    };\n  }, e.tup(y, ct, yt, rt, S, K)),\n  Bt = e.system(function (t) {\n    var n = t[0].totalListHeight,\n      o = t[1].didMount,\n      r = t[2].scrollTo,\n      i = e.statefulStream(0);\n    return e.subscribe(e.pipe(o, e.withLatestFrom(i), e.filter(function (t) {\n      return 0 !== t[1];\n    }), e.map(function (t) {\n      return {\n        top: t[1]\n      };\n    })), function (t) {\n      e.handleNext(e.pipe(n, e.filter(function (t) {\n        return 0 !== t;\n      })), function () {\n        setTimeout(function () {\n          e.publish(r, t);\n        });\n      });\n    }), {\n      initialScrollTop: i\n    };\n  }, e.tup(Lt, mt, y), {\n    singleton: !0\n  }),\n  Pt = e.system(function (t) {\n    var n = t[0].viewportHeight,\n      o = t[1].totalListHeight,\n      r = e.statefulStream(!1);\n    return {\n      alignToBottom: r,\n      paddingTopAddition: e.statefulStreamFromEmitter(e.pipe(e.combineLatest(r, n, o), e.filter(function (t) {\n        return t[0];\n      }), e.map(function (t) {\n        return Math.max(0, t[1] - t[2]);\n      }), e.distinctUntilChanged()), 0)\n    };\n  }, e.tup(y, Lt), {\n    singleton: !0\n  }),\n  Ot = e.system(function (t) {\n    var n = t[0],\n      o = n.scrollTo,\n      r = n.scrollContainerState,\n      i = e.stream(),\n      a = e.stream(),\n      l = e.stream(),\n      s = e.statefulStream(!1),\n      u = e.statefulStream(void 0);\n    return e.connect(e.pipe(e.combineLatest(i, a), e.map(function (t) {\n      var e = t[0],\n        n = e.viewportHeight,\n        o = e.scrollHeight;\n      return {\n        scrollTop: Math.max(0, e.scrollTop - t[1].offsetTop),\n        scrollHeight: o,\n        viewportHeight: n\n      };\n    })), r), e.connect(e.pipe(o, e.withLatestFrom(a), e.map(function (t) {\n      var e = t[0];\n      return c({}, e, {\n        top: e.top + t[1].offsetTop\n      });\n    })), l), {\n      useWindowScroll: s,\n      customScrollParent: u,\n      windowScrollContainerState: i,\n      windowViewportRect: a,\n      windowScrollTo: l\n    };\n  }, e.tup(y)),\n  Mt = [\"done\", \"behavior\", \"align\"],\n  Vt = e.system(function (t) {\n    var n = t[0],\n      o = n.sizes,\n      r = n.totalCount,\n      i = n.gap,\n      a = t[1],\n      l = a.scrollTop,\n      s = a.viewportHeight,\n      u = a.headerHeight,\n      d = a.fixedHeaderHeight,\n      f = a.fixedFooterHeight,\n      p = a.scrollingInProgress,\n      h = t[2].scrollToIndex,\n      g = e.stream();\n    return e.connect(e.pipe(g, e.withLatestFrom(o, s, r, u, d, f, l), e.withLatestFrom(i), e.map(function (t) {\n      var n = t[0],\n        o = n[0],\n        r = n[1],\n        i = n[2],\n        a = n[3],\n        l = n[4],\n        s = n[5],\n        u = n[6],\n        d = n[7],\n        f = t[1],\n        h = o.done,\n        g = o.behavior,\n        v = o.align,\n        S = m(o, Mt),\n        I = null,\n        C = tt(o, r, a - 1),\n        T = X(C, r.offsetTree, f) + l + s;\n      return T < d + s ? I = c({}, S, {\n        behavior: g,\n        align: null != v ? v : \"start\"\n      }) : T + F(r.sizeTree, C)[1] > d + i - u && (I = c({}, S, {\n        behavior: g,\n        align: null != v ? v : \"end\"\n      })), I ? h && e.handleNext(e.pipe(p, e.skip(1), e.filter(function (t) {\n        return !1 === t;\n      })), h) : h && h(), I;\n    }), e.filter(function (t) {\n      return null !== t;\n    })), h), {\n      scrollIntoView: g\n    };\n  }, e.tup(rt, y, lt, yt, S), {\n    singleton: !0\n  }),\n  Ut = [\"listState\", \"topItemsIndexes\"],\n  At = e.system(function (t) {\n    return c({}, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);\n  }, e.tup(Tt, Ht, mt, Et, Lt, Bt, Pt, Ot, Vt)),\n  Wt = e.system(function (t) {\n    var n = t[0],\n      o = n.totalCount,\n      r = n.sizeRanges,\n      i = n.fixedItemSize,\n      a = n.defaultItemSize,\n      l = n.trackItemSizes,\n      s = n.itemSize,\n      u = n.data,\n      d = n.firstItemIndex,\n      f = n.groupIndices,\n      p = n.statefulTotalCount,\n      h = n.gap,\n      g = t[1],\n      v = g.initialTopMostItemIndex,\n      S = g.scrolledToInitialItem,\n      I = t[2],\n      C = t[3],\n      T = t[4],\n      w = T.listState,\n      x = T.topItemsIndexes,\n      b = m(T, Ut),\n      y = t[5].scrollToIndex,\n      H = t[7].topItemCount,\n      E = t[8].groupCounts,\n      R = t[9],\n      L = t[10];\n    return e.connect(b.rangeChanged, R.scrollSeekRangeChanged), e.connect(e.pipe(R.windowViewportRect, e.map(function (t) {\n      return t.visibleHeight;\n    })), I.viewportHeight), c({\n      totalCount: o,\n      data: u,\n      firstItemIndex: d,\n      sizeRanges: r,\n      initialTopMostItemIndex: v,\n      scrolledToInitialItem: S,\n      topItemsIndexes: x,\n      topItemCount: H,\n      groupCounts: E,\n      fixedItemHeight: i,\n      defaultItemHeight: a,\n      gap: h\n    }, C, {\n      statefulTotalCount: p,\n      listState: w,\n      scrollToIndex: y,\n      trackItemSizes: l,\n      itemSize: s,\n      groupIndices: f\n    }, b, R, I, L);\n  }, e.tup(rt, dt, y, pt, yt, lt, zt, Rt, gt, At, S)),\n  Nt = kt(function () {\n    if (\"undefined\" == typeof document) return \"sticky\";\n    var t = document.createElement(\"div\");\n    return t.style.position = \"-webkit-sticky\", \"-webkit-sticky\" === t.style.position ? \"-webkit-sticky\" : \"sticky\";\n  });\nfunction Dt(t, e) {\n  var n = i(null),\n    o = a(function (o) {\n      if (null !== o && o.offsetParent) {\n        var r,\n          i,\n          a = o.getBoundingClientRect(),\n          l = a.width;\n        if (e) {\n          var s = e.getBoundingClientRect(),\n            u = a.top - s.top;\n          r = s.height - Math.max(0, u), i = u + e.scrollTop;\n        } else r = window.innerHeight - Math.max(0, a.top), i = a.top + window.pageYOffset;\n        n.current = {\n          offsetTop: i,\n          visibleHeight: r,\n          visibleWidth: l\n        }, t(n.current);\n      }\n    }, [t, e]),\n    l = I(o),\n    s = l.callbackRef,\n    u = l.ref,\n    c = a(function () {\n      o(u.current);\n    }, [o, u]);\n  return r(function () {\n    if (e) {\n      e.addEventListener(\"scroll\", c);\n      var t = new ResizeObserver(c);\n      return t.observe(e), function () {\n        e.removeEventListener(\"scroll\", c), t.unobserve(e);\n      };\n    }\n    return window.addEventListener(\"scroll\", c), window.addEventListener(\"resize\", c), function () {\n      window.removeEventListener(\"scroll\", c), window.removeEventListener(\"resize\", c);\n    };\n  }, [c, e]), s;\n}\nvar Gt = n.createContext(void 0),\n  _t = [\"placeholder\"],\n  jt = [\"style\", \"children\"],\n  Kt = [\"style\", \"children\"];\nfunction Yt(t) {\n  return t;\n}\nvar qt = e.system(function () {\n  var t = e.statefulStream(function (t) {\n      return \"Item \" + t;\n    }),\n    n = e.statefulStream(null),\n    o = e.statefulStream(function (t) {\n      return \"Group \" + t;\n    }),\n    r = e.statefulStream({}),\n    i = e.statefulStream(Yt),\n    a = e.statefulStream(\"div\"),\n    l = e.statefulStream(e.noop),\n    s = function s(t, n) {\n      return void 0 === n && (n = null), e.statefulStreamFromEmitter(e.pipe(r, e.map(function (e) {\n        return e[t];\n      }), e.distinctUntilChanged()), n);\n    };\n  return {\n    context: n,\n    itemContent: t,\n    groupContent: o,\n    components: r,\n    computeItemKey: i,\n    headerFooterTag: a,\n    scrollerRef: l,\n    FooterComponent: s(\"Footer\"),\n    HeaderComponent: s(\"Header\"),\n    TopItemListComponent: s(\"TopItemList\"),\n    ListComponent: s(\"List\", \"div\"),\n    ItemComponent: s(\"Item\", \"div\"),\n    GroupComponent: s(\"Group\", \"div\"),\n    ScrollerComponent: s(\"Scroller\", \"div\"),\n    EmptyPlaceholder: s(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: s(\"ScrollSeekPlaceholder\")\n  };\n});\nfunction Zt(t, n) {\n  var o = e.stream();\n  return e.subscribe(o, function () {\n    return console.warn(\"react-virtuoso: You are using a deprecated property. \" + n, \"color: red;\", \"color: inherit;\", \"color: blue;\");\n  }), e.connect(o, t), o;\n}\nvar Jt = e.system(function (t) {\n    var n = t[0],\n      o = t[1],\n      r = {\n        item: Zt(o.itemContent, \"Rename the %citem%c prop to %citemContent.\"),\n        group: Zt(o.groupContent, \"Rename the %cgroup%c prop to %cgroupContent.\"),\n        topItems: Zt(n.topItemCount, \"Rename the %ctopItems%c prop to %ctopItemCount.\"),\n        itemHeight: Zt(n.fixedItemHeight, \"Rename the %citemHeight%c prop to %cfixedItemHeight.\"),\n        scrollingStateChange: Zt(n.isScrolling, \"Rename the %cscrollingStateChange%c prop to %cisScrolling.\"),\n        adjustForPrependedItems: e.stream(),\n        maxHeightCacheSize: e.stream(),\n        footer: e.stream(),\n        header: e.stream(),\n        HeaderContainer: e.stream(),\n        FooterContainer: e.stream(),\n        ItemContainer: e.stream(),\n        ScrollContainer: e.stream(),\n        GroupContainer: e.stream(),\n        ListContainer: e.stream(),\n        emptyComponent: e.stream(),\n        scrollSeek: e.stream()\n      };\n    function i(t, n, r) {\n      e.connect(e.pipe(t, e.withLatestFrom(o.components), e.map(function (t) {\n        var e,\n          o = t[0],\n          i = t[1];\n        return console.warn(\"react-virtuoso: \" + r + \" property is deprecated. Pass components.\" + n + \" instead.\"), c({}, i, ((e = {})[n] = o, e));\n      })), o.components);\n    }\n    return e.subscribe(r.adjustForPrependedItems, function () {\n      console.warn(\"react-virtuoso: adjustForPrependedItems is no longer supported. Use the firstItemIndex property instead - https://virtuoso.dev/prepend-items.\", \"color: red;\", \"color: inherit;\", \"color: blue;\");\n    }), e.subscribe(r.maxHeightCacheSize, function () {\n      console.warn(\"react-virtuoso: maxHeightCacheSize is no longer necessary. Setting it has no effect - remove it from your code.\");\n    }), e.subscribe(r.HeaderContainer, function () {\n      console.warn(\"react-virtuoso: HeaderContainer is deprecated. Use headerFooterTag if you want to change the wrapper of the header component and pass components.Header to change its contents.\");\n    }), e.subscribe(r.FooterContainer, function () {\n      console.warn(\"react-virtuoso: FooterContainer is deprecated. Use headerFooterTag if you want to change the wrapper of the footer component and pass components.Footer to change its contents.\");\n    }), e.subscribe(r.scrollSeek, function (t) {\n      var r = t.placeholder,\n        i = m(t, _t);\n      console.warn(\"react-virtuoso: scrollSeek property is deprecated. Pass scrollSeekConfiguration and specify the placeholder in components.ScrollSeekPlaceholder instead.\"), e.publish(o.components, c({}, e.getValue(o.components), {\n        ScrollSeekPlaceholder: r\n      })), e.publish(n.scrollSeekConfiguration, i);\n    }), i(r.footer, \"Footer\", \"footer\"), i(r.header, \"Header\", \"header\"), i(r.ItemContainer, \"Item\", \"ItemContainer\"), i(r.ListContainer, \"List\", \"ListContainer\"), i(r.ScrollContainer, \"Scroller\", \"ScrollContainer\"), i(r.emptyComponent, \"EmptyPlaceholder\", \"emptyComponent\"), i(r.GroupContainer, \"Group\", \"GroupContainer\"), c({}, n, o, r);\n  }, e.tup(Wt, qt)),\n  $t = function $t(t) {\n    return n.createElement(\"div\", {\n      style: {\n        height: t.height\n      }\n    });\n  },\n  Qt = {\n    position: Nt(),\n    zIndex: 1,\n    overflowAnchor: \"none\"\n  },\n  Xt = {\n    overflowAnchor: \"none\"\n  },\n  te = n.memo(function (t) {\n    var o = t.showTopList,\n      r = void 0 !== o && o,\n      i = he(\"listState\"),\n      a = pe(\"sizeRanges\"),\n      s = he(\"useWindowScroll\"),\n      u = he(\"customScrollParent\"),\n      m = pe(\"windowScrollContainerState\"),\n      d = pe(\"scrollContainerState\"),\n      f = u || s ? m : d,\n      p = he(\"itemContent\"),\n      h = he(\"context\"),\n      g = he(\"groupContent\"),\n      v = he(\"trackItemSizes\"),\n      S = he(\"itemSize\"),\n      I = he(\"log\"),\n      C = pe(\"gap\"),\n      w = T(a, S, v, r ? e.noop : f, I, C, u).callbackRef,\n      x = n.useState(0),\n      b = x[0],\n      y = x[1];\n    ge(\"deviation\", function (t) {\n      b !== t && y(t);\n    });\n    var H = he(\"EmptyPlaceholder\"),\n      E = he(\"ScrollSeekPlaceholder\") || $t,\n      R = he(\"ListComponent\"),\n      L = he(\"ItemComponent\"),\n      k = he(\"GroupComponent\"),\n      F = he(\"computeItemKey\"),\n      z = he(\"isSeeking\"),\n      B = he(\"groupIndices\").length > 0,\n      P = he(\"paddingTopAddition\"),\n      O = r ? {} : {\n        boxSizing: \"border-box\",\n        paddingTop: i.offsetTop + P,\n        paddingBottom: i.offsetBottom,\n        marginTop: b\n      };\n    return !r && 0 === i.totalCount && H ? l(H, re(H, h)) : l(R, c({}, re(R, h), {\n      ref: w,\n      style: O,\n      \"data-test-id\": r ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\"\n    }), (r ? i.topItems : i.items).map(function (t) {\n      var e = t.originalIndex,\n        n = F(e + i.firstItemIndex, t.data, h);\n      return z ? l(E, c({}, re(E, h), {\n        key: n,\n        index: t.index,\n        height: t.size,\n        type: t.type || \"item\"\n      }, \"group\" === t.type ? {} : {\n        groupIndex: t.groupIndex\n      })) : \"group\" === t.type ? l(k, c({}, re(k, h), {\n        key: n,\n        \"data-index\": e,\n        \"data-known-size\": t.size,\n        \"data-item-index\": t.index,\n        style: Qt\n      }), g(t.index)) : l(L, c({}, re(L, h), {\n        key: n,\n        \"data-index\": e,\n        \"data-known-size\": t.size,\n        \"data-item-index\": t.index,\n        \"data-item-group-index\": t.groupIndex,\n        style: Xt\n      }), B ? p(t.index, t.groupIndex, t.data, h) : p(t.index, t.data, h));\n    }));\n  }),\n  ee = {\n    height: \"100%\",\n    outline: \"none\",\n    overflowY: \"auto\",\n    position: \"relative\",\n    WebkitOverflowScrolling: \"touch\"\n  },\n  ne = {\n    width: \"100%\",\n    height: \"100%\",\n    position: \"absolute\",\n    top: 0\n  },\n  oe = {\n    width: \"100%\",\n    position: Nt(),\n    top: 0\n  };\nfunction re(t, e) {\n  if (\"string\" != typeof t) return {\n    context: e\n  };\n}\nvar ie = n.memo(function () {\n    var t = he(\"HeaderComponent\"),\n      e = pe(\"headerHeight\"),\n      n = he(\"headerFooterTag\"),\n      o = C(function (t) {\n        return e(w(t, \"height\"));\n      }),\n      r = he(\"context\");\n    return t ? l(n, {\n      ref: o\n    }, l(t, re(t, r))) : null;\n  }),\n  ae = n.memo(function () {\n    var t = he(\"FooterComponent\"),\n      e = pe(\"footerHeight\"),\n      n = he(\"headerFooterTag\"),\n      o = C(function (t) {\n        return e(w(t, \"height\"));\n      }),\n      r = he(\"context\");\n    return t ? l(n, {\n      ref: o\n    }, l(t, re(t, r))) : null;\n  });\nfunction le(t) {\n  var e = t.usePublisher,\n    o = t.useEmitter,\n    r = t.useEmitterValue;\n  return n.memo(function (t) {\n    var n = t.style,\n      i = t.children,\n      a = m(t, jt),\n      s = e(\"scrollContainerState\"),\n      u = r(\"ScrollerComponent\"),\n      d = e(\"smoothScrollTargetReached\"),\n      f = r(\"scrollerRef\"),\n      p = r(\"context\"),\n      h = b(s, d, u, f),\n      g = h.scrollerRef,\n      v = h.scrollByCallback;\n    return o(\"scrollTo\", h.scrollToCallback), o(\"scrollBy\", v), l(u, c({\n      ref: g,\n      style: c({}, ee, n),\n      \"data-test-id\": \"virtuoso-scroller\",\n      \"data-virtuoso-scroller\": !0,\n      tabIndex: 0\n    }, a, re(u, p)), i);\n  });\n}\nfunction se(t) {\n  var o = t.usePublisher,\n    r = t.useEmitter,\n    i = t.useEmitterValue;\n  return n.memo(function (t) {\n    var n = t.style,\n      a = t.children,\n      s = m(t, Kt),\n      u = o(\"windowScrollContainerState\"),\n      d = i(\"ScrollerComponent\"),\n      f = o(\"smoothScrollTargetReached\"),\n      p = i(\"totalListHeight\"),\n      h = i(\"deviation\"),\n      v = i(\"customScrollParent\"),\n      S = i(\"context\"),\n      I = b(u, f, d, e.noop, v),\n      C = I.scrollerRef,\n      T = I.scrollByCallback,\n      w = I.scrollToCallback;\n    return g(function () {\n      return C.current = v || window, function () {\n        C.current = null;\n      };\n    }, [C, v]), r(\"windowScrollTo\", w), r(\"scrollBy\", T), l(d, c({\n      style: c({\n        position: \"relative\"\n      }, n, 0 !== p ? {\n        height: p + h\n      } : {}),\n      \"data-virtuoso-scroller\": !0\n    }, s, re(d, S)), a);\n  });\n}\nvar ue = function ue(t) {\n    var o = t.children,\n      r = s(Gt),\n      i = pe(\"viewportHeight\"),\n      a = pe(\"fixedItemHeight\"),\n      l = C(e.compose(i, function (t) {\n        return w(t, \"height\");\n      }));\n    return n.useEffect(function () {\n      r && (i(r.viewportHeight), a(r.itemHeight));\n    }, [r, i, a]), n.createElement(\"div\", {\n      style: ne,\n      ref: l,\n      \"data-viewport-type\": \"element\"\n    }, o);\n  },\n  ce = function ce(t) {\n    var e = t.children,\n      o = s(Gt),\n      r = pe(\"windowViewportRect\"),\n      i = pe(\"fixedItemHeight\"),\n      a = he(\"customScrollParent\"),\n      l = Dt(r, a);\n    return n.useEffect(function () {\n      o && (i(o.itemHeight), r({\n        offsetTop: 0,\n        visibleHeight: o.viewportHeight,\n        visibleWidth: 100\n      }));\n    }, [o, r, i]), n.createElement(\"div\", {\n      ref: l,\n      style: ne,\n      \"data-viewport-type\": \"window\"\n    }, e);\n  },\n  me = function me(t) {\n    var e = t.children,\n      n = he(\"TopItemListComponent\"),\n      o = he(\"headerHeight\"),\n      r = c({}, oe, {\n        marginTop: o + \"px\"\n      }),\n      i = he(\"context\");\n    return l(n || \"div\", {\n      style: r,\n      context: i\n    }, e);\n  },\n  de = t(Jt, {\n    required: {},\n    optional: {\n      context: \"context\",\n      followOutput: \"followOutput\",\n      firstItemIndex: \"firstItemIndex\",\n      itemContent: \"itemContent\",\n      groupContent: \"groupContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      topItemCount: \"topItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      groupCounts: \"groupCounts\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"headerFooterTag\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\",\n      react18ConcurrentRendering: \"react18ConcurrentRendering\",\n      item: \"item\",\n      group: \"group\",\n      topItems: \"topItems\",\n      itemHeight: \"itemHeight\",\n      scrollingStateChange: \"scrollingStateChange\",\n      maxHeightCacheSize: \"maxHeightCacheSize\",\n      footer: \"footer\",\n      header: \"header\",\n      ItemContainer: \"ItemContainer\",\n      ScrollContainer: \"ScrollContainer\",\n      ListContainer: \"ListContainer\",\n      GroupContainer: \"GroupContainer\",\n      emptyComponent: \"emptyComponent\",\n      HeaderContainer: \"HeaderContainer\",\n      FooterContainer: \"FooterContainer\",\n      scrollSeek: \"scrollSeek\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      adjustForPrependedItems: \"adjustForPrependedItems\",\n      autoscrollToBottom: \"autoscrollToBottom\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  }, n.memo(function (t) {\n    var e = he(\"useWindowScroll\"),\n      o = he(\"topItemsIndexes\").length > 0,\n      r = he(\"customScrollParent\"),\n      i = r || e ? ce : ue;\n    return n.createElement(r || e ? Se : ve, c({}, t), n.createElement(i, null, n.createElement(ie, null), n.createElement(te, null), n.createElement(ae, null)), o && n.createElement(me, null, n.createElement(te, {\n      showTopList: !0\n    })));\n  })),\n  fe = de.Component,\n  pe = de.usePublisher,\n  he = de.useEmitterValue,\n  ge = de.useEmitter,\n  ve = le({\n    usePublisher: pe,\n    useEmitterValue: he,\n    useEmitter: ge\n  }),\n  Se = se({\n    usePublisher: pe,\n    useEmitterValue: he,\n    useEmitter: ge\n  }),\n  Ie = {\n    items: [],\n    offsetBottom: 0,\n    offsetTop: 0,\n    top: 0,\n    bottom: 0,\n    itemHeight: 0,\n    itemWidth: 0\n  },\n  Ce = {\n    items: [{\n      index: 0\n    }],\n    offsetBottom: 0,\n    offsetTop: 0,\n    top: 0,\n    bottom: 0,\n    itemHeight: 0,\n    itemWidth: 0\n  },\n  Te = Math.round,\n  we = Math.ceil,\n  xe = Math.floor,\n  be = Math.min,\n  ye = Math.max;\nfunction He(t, e) {\n  return Array.from({\n    length: e - t + 1\n  }).map(function (e, n) {\n    return {\n      index: n + t\n    };\n  });\n}\nfunction Ee(t, e) {\n  return t && t.column === e.column && t.row === e.row;\n}\nvar Re = e.system(function (t) {\n  var n = t[0],\n    o = n.overscan,\n    r = n.visibleRange,\n    i = n.listBoundary,\n    a = t[1],\n    l = a.scrollTop,\n    s = a.viewportHeight,\n    u = a.scrollBy,\n    m = a.scrollTo,\n    d = a.smoothScrollTargetReached,\n    f = a.scrollContainerState,\n    p = t[2],\n    h = t[3],\n    g = t[4],\n    v = g.propsReady,\n    S = g.didMount,\n    I = t[5],\n    C = I.windowViewportRect,\n    T = I.windowScrollTo,\n    w = I.useWindowScroll,\n    x = I.customScrollParent,\n    b = I.windowScrollContainerState,\n    y = t[6],\n    H = e.statefulStream(0),\n    E = e.statefulStream(0),\n    R = e.statefulStream(Ie),\n    L = e.statefulStream({\n      height: 0,\n      width: 0\n    }),\n    k = e.statefulStream({\n      height: 0,\n      width: 0\n    }),\n    F = e.stream(),\n    z = e.stream(),\n    B = e.statefulStream(0),\n    P = e.statefulStream({\n      row: 0,\n      column: 0\n    });\n  e.connect(e.pipe(S, e.withLatestFrom(E), e.filter(function (t) {\n    return 0 !== t[1];\n  }), e.map(function (t) {\n    return {\n      items: He(0, t[1] - 1),\n      top: 0,\n      bottom: 0,\n      offsetBottom: 0,\n      offsetTop: 0,\n      itemHeight: 0,\n      itemWidth: 0\n    };\n  })), R), e.connect(e.pipe(e.combineLatest(e.duc(H), r, e.duc(P, Ee), e.duc(k, function (t, e) {\n    return t && t.width === e.width && t.height === e.height;\n  })), e.withLatestFrom(L), e.map(function (t) {\n    var e = t[0],\n      n = e[0],\n      o = e[1],\n      r = o[0],\n      i = o[1],\n      a = e[2],\n      l = e[3],\n      s = t[1],\n      u = a.row,\n      c = l.height,\n      m = l.width,\n      d = s.width;\n    if (0 === n || 0 === d) return Ie;\n    if (0 === m) return Ce;\n    var f = Fe(d, m, a.column),\n      p = f * xe((r + u) / (c + u)),\n      h = f * we((i + u) / (c + u)) - 1;\n    h = ye(0, be(n - 1, h));\n    var g = He(p = be(h, ye(0, p)), h),\n      v = Le(s, a, l, g),\n      S = v.top,\n      I = v.bottom,\n      C = we(n / f);\n    return {\n      items: g,\n      offsetTop: S,\n      offsetBottom: C * c + (C - 1) * u - I,\n      top: S,\n      bottom: I,\n      itemHeight: c,\n      itemWidth: m\n    };\n  })), R), e.connect(e.pipe(L, e.map(function (t) {\n    return t.height;\n  })), s), e.connect(e.pipe(e.combineLatest(L, k, R, P), e.map(function (t) {\n    var e = Le(t[0], t[3], t[1], t[2].items);\n    return [e.top, e.bottom];\n  }), e.distinctUntilChanged(vt)), i);\n  var O = e.streamFromEmitter(e.pipe(e.duc(R), e.filter(function (t) {\n      return t.items.length > 0;\n    }), e.withLatestFrom(H), e.filter(function (t) {\n      var e = t[0].items;\n      return e[e.length - 1].index === t[1] - 1;\n    }), e.map(function (t) {\n      return t[1] - 1;\n    }), e.distinctUntilChanged())),\n    M = e.streamFromEmitter(e.pipe(e.duc(R), e.filter(function (t) {\n      var e = t.items;\n      return e.length > 0 && 0 === e[0].index;\n    }), e.mapTo(0), e.distinctUntilChanged())),\n    V = e.streamFromEmitter(e.pipe(e.duc(R), e.filter(function (t) {\n      return t.items.length > 0;\n    }), e.map(function (t) {\n      var e = t.items;\n      return {\n        startIndex: e[0].index,\n        endIndex: e[e.length - 1].index\n      };\n    }), e.distinctUntilChanged(St)));\n  e.connect(V, h.scrollSeekRangeChanged), e.connect(e.pipe(F, e.withLatestFrom(L, k, H, P), e.map(function (t) {\n    var e = t[1],\n      n = t[2],\n      o = t[3],\n      r = t[4],\n      i = at(t[0]),\n      a = i.align,\n      l = i.behavior,\n      s = i.offset,\n      u = i.index;\n    \"LAST\" === u && (u = o - 1);\n    var c = ke(e, r, n, u = ye(0, u, be(o - 1, u)));\n    return \"end\" === a ? c = Te(c - e.height + n.height) : \"center\" === a && (c = Te(c - e.height / 2 + n.height / 2)), s && (c += s), {\n      top: c,\n      behavior: l\n    };\n  })), m);\n  var U = e.statefulStreamFromEmitter(e.pipe(R, e.map(function (t) {\n    return t.offsetBottom + t.bottom;\n  })), 0);\n  return e.connect(e.pipe(C, e.map(function (t) {\n    return {\n      width: t.visibleWidth,\n      height: t.visibleHeight\n    };\n  })), L), c({\n    totalCount: H,\n    viewportDimensions: L,\n    itemDimensions: k,\n    scrollTop: l,\n    scrollHeight: z,\n    overscan: o,\n    scrollBy: u,\n    scrollTo: m,\n    scrollToIndex: F,\n    smoothScrollTargetReached: d,\n    windowViewportRect: C,\n    windowScrollTo: T,\n    useWindowScroll: w,\n    customScrollParent: x,\n    windowScrollContainerState: b,\n    deviation: B,\n    scrollContainerState: f,\n    initialItemCount: E,\n    gap: P\n  }, h, {\n    gridState: R,\n    totalListHeight: U\n  }, p, {\n    startReached: M,\n    endReached: O,\n    rangeChanged: V,\n    propsReady: v\n  }, y);\n}, e.tup(Tt, y, ct, Et, mt, Ot, S));\nfunction Le(t, e, n, o) {\n  var r = n.height;\n  return void 0 === r || 0 === o.length ? {\n    top: 0,\n    bottom: 0\n  } : {\n    top: ke(t, e, n, o[0].index),\n    bottom: ke(t, e, n, o[o.length - 1].index) + r\n  };\n}\nfunction ke(t, e, n, o) {\n  var r = Fe(t.width, n.width, e.column),\n    i = xe(o / r),\n    a = i * n.height + ye(0, i - 1) * e.row;\n  return a > 0 ? a + e.row : a;\n}\nfunction Fe(t, e, n) {\n  return ye(1, xe((t + n) / (e + n)));\n}\nvar ze = [\"placeholder\"],\n  Be = e.system(function () {\n    var t = e.statefulStream(function (t) {\n        return \"Item \" + t;\n      }),\n      n = e.statefulStream({}),\n      o = e.statefulStream(null),\n      r = e.statefulStream(\"virtuoso-grid-item\"),\n      i = e.statefulStream(\"virtuoso-grid-list\"),\n      a = e.statefulStream(Yt),\n      l = e.statefulStream(e.noop),\n      s = function s(t, o) {\n        return void 0 === o && (o = null), e.statefulStreamFromEmitter(e.pipe(n, e.map(function (e) {\n          return e[t];\n        }), e.distinctUntilChanged()), o);\n      };\n    return {\n      context: o,\n      itemContent: t,\n      components: n,\n      computeItemKey: a,\n      itemClassName: r,\n      listClassName: i,\n      scrollerRef: l,\n      ListComponent: s(\"List\", \"div\"),\n      ItemComponent: s(\"Item\", \"div\"),\n      ScrollerComponent: s(\"Scroller\", \"div\"),\n      ScrollSeekPlaceholder: s(\"ScrollSeekPlaceholder\", \"div\")\n    };\n  }),\n  Pe = e.system(function (t) {\n    var n = t[0],\n      o = t[1],\n      r = {\n        item: Zt(o.itemContent, \"Rename the %citem%c prop to %citemContent.\"),\n        ItemContainer: e.stream(),\n        ScrollContainer: e.stream(),\n        ListContainer: e.stream(),\n        emptyComponent: e.stream(),\n        scrollSeek: e.stream()\n      };\n    function i(t, n, r) {\n      e.connect(e.pipe(t, e.withLatestFrom(o.components), e.map(function (t) {\n        var e,\n          o = t[0],\n          i = t[1];\n        return console.warn(\"react-virtuoso: \" + r + \" property is deprecated. Pass components.\" + n + \" instead.\"), c({}, i, ((e = {})[n] = o, e));\n      })), o.components);\n    }\n    return e.subscribe(r.scrollSeek, function (t) {\n      var r = t.placeholder,\n        i = m(t, ze);\n      console.warn(\"react-virtuoso: scrollSeek property is deprecated. Pass scrollSeekConfiguration and specify the placeholder in components.ScrollSeekPlaceholder instead.\"), e.publish(o.components, c({}, e.getValue(o.components), {\n        ScrollSeekPlaceholder: r\n      })), e.publish(n.scrollSeekConfiguration, i);\n    }), i(r.ItemContainer, \"Item\", \"ItemContainer\"), i(r.ListContainer, \"List\", \"ListContainer\"), i(r.ScrollContainer, \"Scroller\", \"ScrollContainer\"), c({}, n, o, r);\n  }, e.tup(Re, Be)),\n  Oe = n.memo(function () {\n    var t = Ne(\"gridState\"),\n      e = Ne(\"listClassName\"),\n      n = Ne(\"itemClassName\"),\n      o = Ne(\"itemContent\"),\n      r = Ne(\"computeItemKey\"),\n      i = Ne(\"isSeeking\"),\n      a = We(\"scrollHeight\"),\n      s = Ne(\"ItemComponent\"),\n      u = Ne(\"ListComponent\"),\n      m = Ne(\"ScrollSeekPlaceholder\"),\n      d = Ne(\"context\"),\n      f = We(\"itemDimensions\"),\n      p = We(\"gap\"),\n      h = Ne(\"log\"),\n      g = C(function (t) {\n        a(t.parentElement.parentElement.scrollHeight);\n        var e = t.firstChild;\n        e && f(e.getBoundingClientRect()), p({\n          row: je(\"row-gap\", getComputedStyle(t).rowGap, h),\n          column: je(\"column-gap\", getComputedStyle(t).columnGap, h)\n        });\n      });\n    return l(u, c({\n      ref: g,\n      className: e\n    }, re(u, d), {\n      style: {\n        paddingTop: t.offsetTop,\n        paddingBottom: t.offsetBottom\n      }\n    }), t.items.map(function (e) {\n      var a = r(e.index);\n      return i ? l(m, c({\n        key: a\n      }, re(m, d), {\n        index: e.index,\n        height: t.itemHeight,\n        width: t.itemWidth\n      })) : l(s, c({}, re(s, d), {\n        className: n,\n        \"data-index\": e.index,\n        key: a\n      }), o(e.index, d));\n    }));\n  }),\n  Me = function Me(t) {\n    var e = t.children,\n      o = We(\"viewportDimensions\"),\n      r = C(function (t) {\n        o(t.getBoundingClientRect());\n      });\n    return n.createElement(\"div\", {\n      style: ne,\n      ref: r\n    }, e);\n  },\n  Ve = function Ve(t) {\n    var e = t.children,\n      o = Dt(We(\"windowViewportRect\"), Ne(\"customScrollParent\"));\n    return n.createElement(\"div\", {\n      ref: o,\n      style: ne\n    }, e);\n  },\n  Ue = t(Pe, {\n    optional: {\n      context: \"context\",\n      totalCount: \"totalCount\",\n      overscan: \"overscan\",\n      itemContent: \"itemContent\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      initialItemCount: \"initialItemCount\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      listClassName: \"listClassName\",\n      itemClassName: \"itemClassName\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      item: \"item\",\n      ItemContainer: \"ItemContainer\",\n      ScrollContainer: \"ScrollContainer\",\n      ListContainer: \"ListContainer\",\n      scrollSeek: \"scrollSeek\"\n    },\n    methods: {\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\"\n    }\n  }, n.memo(function (t) {\n    var e = c({}, t),\n      o = Ne(\"useWindowScroll\"),\n      r = Ne(\"customScrollParent\"),\n      i = r || o ? Ve : Me;\n    return n.createElement(r || o ? _e : Ge, c({}, e), n.createElement(i, null, n.createElement(Oe, null)));\n  })),\n  Ae = Ue.Component,\n  We = Ue.usePublisher,\n  Ne = Ue.useEmitterValue,\n  De = Ue.useEmitter,\n  Ge = le({\n    usePublisher: We,\n    useEmitterValue: Ne,\n    useEmitter: De\n  }),\n  _e = se({\n    usePublisher: We,\n    useEmitterValue: Ne,\n    useEmitter: De\n  });\nfunction je(t, e, n) {\n  return \"normal\" === e || null != e && e.endsWith(\"px\") || n(t + \" was not resolved to pixel value correctly\", e, h.WARN), \"normal\" === e ? 0 : parseInt(null != e ? e : \"0\", 10);\n}\nvar Ke = e.system(function () {\n    var t = e.statefulStream(function (t) {\n        return n.createElement(\"td\", null, \"Item $\", t);\n      }),\n      o = e.statefulStream(null),\n      r = e.statefulStream(null),\n      i = e.statefulStream(null),\n      a = e.statefulStream({}),\n      l = e.statefulStream(Yt),\n      s = e.statefulStream(e.noop),\n      u = function u(t, n) {\n        return void 0 === n && (n = null), e.statefulStreamFromEmitter(e.pipe(a, e.map(function (e) {\n          return e[t];\n        }), e.distinctUntilChanged()), n);\n      };\n    return {\n      context: o,\n      itemContent: t,\n      fixedHeaderContent: r,\n      fixedFooterContent: i,\n      components: a,\n      computeItemKey: l,\n      scrollerRef: s,\n      TableComponent: u(\"Table\", \"table\"),\n      TableHeadComponent: u(\"TableHead\", \"thead\"),\n      TableFooterComponent: u(\"TableFoot\", \"tfoot\"),\n      TableBodyComponent: u(\"TableBody\", \"tbody\"),\n      TableRowComponent: u(\"TableRow\", \"tr\"),\n      ScrollerComponent: u(\"Scroller\", \"div\"),\n      EmptyPlaceholder: u(\"EmptyPlaceholder\"),\n      ScrollSeekPlaceholder: u(\"ScrollSeekPlaceholder\"),\n      FillerRow: u(\"FillerRow\")\n    };\n  }),\n  Ye = e.system(function (t) {\n    return c({}, t[0], t[1]);\n  }, e.tup(Wt, Ke)),\n  qe = function qe(t) {\n    return n.createElement(\"tr\", null, n.createElement(\"td\", {\n      style: {\n        height: t.height\n      }\n    }));\n  },\n  Ze = function Ze(t) {\n    return n.createElement(\"tr\", null, n.createElement(\"td\", {\n      style: {\n        height: t.height,\n        padding: 0,\n        border: 0\n      }\n    }));\n  },\n  Je = n.memo(function () {\n    var t = nn(\"listState\"),\n      e = en(\"sizeRanges\"),\n      o = nn(\"useWindowScroll\"),\n      r = nn(\"customScrollParent\"),\n      i = en(\"windowScrollContainerState\"),\n      a = en(\"scrollContainerState\"),\n      s = r || o ? i : a,\n      u = nn(\"itemContent\"),\n      m = nn(\"trackItemSizes\"),\n      d = T(e, nn(\"itemSize\"), m, s, nn(\"log\"), void 0, r),\n      f = d.callbackRef,\n      p = d.ref,\n      h = n.useState(0),\n      g = h[0],\n      v = h[1];\n    on(\"deviation\", function (t) {\n      g !== t && (p.current.style.marginTop = t + \"px\", v(t));\n    });\n    var S = nn(\"EmptyPlaceholder\"),\n      I = nn(\"ScrollSeekPlaceholder\") || qe,\n      C = nn(\"FillerRow\") || Ze,\n      w = nn(\"TableBodyComponent\"),\n      x = nn(\"TableRowComponent\"),\n      b = nn(\"computeItemKey\"),\n      y = nn(\"isSeeking\"),\n      H = nn(\"paddingTopAddition\"),\n      E = nn(\"firstItemIndex\"),\n      R = nn(\"statefulTotalCount\"),\n      L = nn(\"context\");\n    if (0 === R && S) return l(S, re(S, L));\n    var k = t.offsetTop + H + g,\n      F = t.offsetBottom,\n      z = k > 0 ? n.createElement(C, {\n        height: k,\n        key: \"padding-top\"\n      }) : null,\n      B = F > 0 ? n.createElement(C, {\n        height: F,\n        key: \"padding-bottom\"\n      }) : null,\n      P = t.items.map(function (t) {\n        var e = t.originalIndex,\n          n = b(e + E, t.data, L);\n        return y ? l(I, c({}, re(I, L), {\n          key: n,\n          index: t.index,\n          height: t.size,\n          type: t.type || \"item\"\n        })) : l(x, c({}, re(x, L), {\n          key: n,\n          \"data-index\": e,\n          \"data-known-size\": t.size,\n          \"data-item-index\": t.index,\n          style: {\n            overflowAnchor: \"none\"\n          }\n        }), u(t.index, t.data, L));\n      });\n    return l(w, c({\n      ref: f,\n      \"data-test-id\": \"virtuoso-item-list\"\n    }, re(w, L)), [z].concat(P, [B]));\n  }),\n  $e = function $e(t) {\n    var o = t.children,\n      r = s(Gt),\n      i = en(\"viewportHeight\"),\n      a = en(\"fixedItemHeight\"),\n      l = C(e.compose(i, function (t) {\n        return w(t, \"height\");\n      }));\n    return n.useEffect(function () {\n      r && (i(r.viewportHeight), a(r.itemHeight));\n    }, [r, i, a]), n.createElement(\"div\", {\n      style: ne,\n      ref: l,\n      \"data-viewport-type\": \"element\"\n    }, o);\n  },\n  Qe = function Qe(t) {\n    var e = t.children,\n      o = s(Gt),\n      r = en(\"windowViewportRect\"),\n      i = en(\"fixedItemHeight\"),\n      a = nn(\"customScrollParent\"),\n      l = Dt(r, a);\n    return n.useEffect(function () {\n      o && (i(o.itemHeight), r({\n        offsetTop: 0,\n        visibleHeight: o.viewportHeight,\n        visibleWidth: 100\n      }));\n    }, [o, r, i]), n.createElement(\"div\", {\n      ref: l,\n      style: ne,\n      \"data-viewport-type\": \"window\"\n    }, e);\n  },\n  Xe = t(Ye, {\n    required: {},\n    optional: {\n      context: \"context\",\n      followOutput: \"followOutput\",\n      firstItemIndex: \"firstItemIndex\",\n      itemContent: \"itemContent\",\n      fixedHeaderContent: \"fixedHeaderContent\",\n      fixedFooterContent: \"fixedFooterContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      topItemCount: \"topItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      groupCounts: \"groupCounts\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\",\n      react18ConcurrentRendering: \"react18ConcurrentRendering\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  }, n.memo(function (t) {\n    var o = nn(\"useWindowScroll\"),\n      r = nn(\"customScrollParent\"),\n      i = en(\"fixedHeaderHeight\"),\n      a = en(\"fixedFooterHeight\"),\n      l = nn(\"fixedHeaderContent\"),\n      s = nn(\"fixedFooterContent\"),\n      u = nn(\"context\"),\n      m = C(e.compose(i, function (t) {\n        return w(t, \"height\");\n      })),\n      d = C(e.compose(a, function (t) {\n        return w(t, \"height\");\n      })),\n      f = r || o ? an : rn,\n      p = r || o ? Qe : $e,\n      h = nn(\"TableComponent\"),\n      g = nn(\"TableHeadComponent\"),\n      v = nn(\"TableFooterComponent\"),\n      S = l ? n.createElement(g, c({\n        key: \"TableHead\",\n        style: {\n          zIndex: 1,\n          position: \"sticky\",\n          top: 0\n        },\n        ref: m\n      }, re(g, u)), l()) : null,\n      I = s ? n.createElement(v, c({\n        key: \"TableFoot\",\n        style: {\n          zIndex: 1,\n          position: \"sticky\",\n          bottom: 0\n        },\n        ref: d\n      }, re(v, u)), s()) : null;\n    return n.createElement(f, c({}, t), n.createElement(p, null, n.createElement(h, c({\n      style: {\n        borderSpacing: 0\n      }\n    }, re(h, u)), [S, n.createElement(Je, {\n      key: \"TableBody\"\n    }), I])));\n  })),\n  tn = Xe.Component,\n  en = Xe.usePublisher,\n  nn = Xe.useEmitterValue,\n  on = Xe.useEmitter,\n  rn = le({\n    usePublisher: en,\n    useEmitterValue: nn,\n    useEmitter: on\n  }),\n  an = se({\n    usePublisher: en,\n    useEmitterValue: nn,\n    useEmitter: on\n  }),\n  ln = fe,\n  sn = fe,\n  un = tn,\n  cn = Ae;\nexport { sn as GroupedVirtuoso, h as LogLevel, un as TableVirtuoso, ln as Virtuoso, cn as VirtuosoGrid, Gt as VirtuosoMockContext };","map":null,"metadata":{},"sourceType":"module"}