{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/ebubechi/Desktop/UniVerse/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/ebubechi/Desktop/UniVerse/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar ICAL = require('ical.js');\n\n// Copied from https://dxr.mozilla.org/comm-central/source/calendar/timezones/zones.json\n// And compiled using node compile-zones.js\n// See also https://github.com/mozilla-comm/ical.js/issues/195\nvar timezones = require('./zones-compiled.json');\nvar IcalExpander = /*#__PURE__*/function () {\n  function IcalExpander(opts) {\n    _classCallCheck(this, IcalExpander);\n    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1000;\n    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;\n    this.jCalData = ICAL.parse(opts.ics);\n    this.component = new ICAL.Component(this.jCalData);\n    this.events = this.component.getAllSubcomponents('vevent').map(function (vevent) {\n      return new ICAL.Event(vevent);\n    });\n    if (this.skipInvalidDates) {\n      this.events = this.events.filter(function (evt) {\n        try {\n          evt.startDate.toJSDate();\n          evt.endDate.toJSDate();\n          return true;\n        } catch (err) {\n          // skipping events with invalid time\n          return false;\n        }\n      });\n    }\n  }\n  _createClass(IcalExpander, [{\n    key: \"between\",\n    value: function between(after, before) {\n      var _this = this;\n      function isEventWithinRange(startTime, endTime) {\n        return (!after || endTime >= after.getTime()) && (!before || startTime <= before.getTime());\n      }\n      function getTimes(eventOrOccurrence) {\n        var startTime = eventOrOccurrence.startDate.toJSDate().getTime();\n        var endTime = eventOrOccurrence.endDate.toJSDate().getTime();\n\n        // If it is an all day event, the end date is set to 00:00 of the next day\n        // So we need to make it be 23:59:59 to compare correctly with the given range\n        if (eventOrOccurrence.endDate.isDate && endTime > startTime) {\n          endTime -= 1;\n        }\n        return {\n          startTime: startTime,\n          endTime: endTime\n        };\n      }\n      var exceptions = [];\n      this.events.forEach(function (event) {\n        if (event.isRecurrenceException()) exceptions.push(event);\n      });\n      var ret = {\n        events: [],\n        occurrences: []\n      };\n      this.events.filter(function (e) {\n        return !e.isRecurrenceException();\n      }).forEach(function (event) {\n        var exdates = [];\n        event.component.getAllProperties('exdate').forEach(function (exdateProp) {\n          var exdate = exdateProp.getFirstValue();\n          exdates.push(exdate.toJSDate().getTime());\n        });\n\n        // Recurring event is handled differently\n        if (event.isRecurring()) {\n          var iterator = event.iterator();\n          var next;\n          var i = 0;\n          var _loop = function _loop() {\n            i += 1;\n            next = iterator.next();\n            if (next) {\n              var occurrence = event.getOccurrenceDetails(next);\n              var _getTimes = getTimes(occurrence),\n                _startTime = _getTimes.startTime,\n                _endTime = _getTimes.endTime;\n              var isOccurrenceExcluded = exdates.indexOf(_startTime) !== -1;\n\n              // TODO check that within same day?\n              var exception = exceptions.find(function (ex) {\n                return ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime();\n              });\n\n              // We have passed the max date, stop\n              if (before && _startTime > before.getTime()) return \"break\";\n\n              // Check that we are within our range\n              if (isEventWithinRange(_startTime, _endTime)) {\n                if (exception) {\n                  ret.events.push(exception);\n                } else if (!isOccurrenceExcluded) {\n                  ret.occurrences.push(occurrence);\n                }\n              }\n            }\n          };\n          do {\n            var _ret = _loop();\n            if (_ret === \"break\") break;\n          } while (next && (!_this.maxIterations || i < _this.maxIterations));\n          return;\n        }\n\n        // Non-recurring event:\n        var _getTimes2 = getTimes(event),\n          startTime = _getTimes2.startTime,\n          endTime = _getTimes2.endTime;\n        if (isEventWithinRange(startTime, endTime)) ret.events.push(event);\n      });\n      return ret;\n    }\n  }, {\n    key: \"before\",\n    value: function before(_before) {\n      return this.between(undefined, _before);\n    }\n  }, {\n    key: \"after\",\n    value: function after(_after) {\n      return this.between(_after);\n    }\n  }, {\n    key: \"all\",\n    value: function all() {\n      return this.between();\n    }\n  }]);\n  return IcalExpander;\n}();\nfunction registerTimezones() {\n  Object.keys(timezones).forEach(function (key) {\n    var icsData = timezones[key];\n    var icsTimezone = \"BEGIN:VTIMEZONE\\r\\nTZID:\".concat(key, \"\\r\\n\").concat(icsData, \"\\r\\nEND:VTIMEZONE\");\n    var parsed = ICAL.parse(\"BEGIN:VCALENDAR\\nPRODID:-//tzurl.org//NONSGML Olson 2012h//EN\\nVERSION:2.0\\n\".concat(icsTimezone, \"\\nEND:VCALENDAR\"));\n    var comp = new ICAL.Component(parsed);\n    var vtimezone = comp.getFirstSubcomponent('vtimezone');\n    ICAL.TimezoneService.register(key, new ICAL.Timezone(vtimezone));\n  });\n}\nregisterTimezones();\nmodule.exports = IcalExpander;","map":null,"metadata":{},"sourceType":"script"}