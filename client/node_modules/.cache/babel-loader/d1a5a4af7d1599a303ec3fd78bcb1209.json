{"ast":null,"code":"'use strict';\n\nvar asciiDigit = require('../character/ascii-digit.js');\nvar markdownSpace = require('../character/markdown-space.js');\nvar prefixSize = require('../util/prefix-size.js');\nvar sizeChunks = require('../util/size-chunks.js');\nvar factorySpace = require('./factory-space.js');\nvar partialBlankLine = require('./partial-blank-line.js');\nvar thematicBreak = require('./thematic-break.js');\nvar list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n};\nvar listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n};\nvar indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\nfunction tokenizeListStart(effects, ok, nok) {\n  var self = this;\n  var initialSize = prefixSize(self.events, 'linePrefix');\n  var size = 0;\n  return start;\n  function start(code) {\n    var kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? 'listUnordered' : 'listOrdered');\n    if (kind === 'listUnordered' ? !self.containerState.marker || code === self.containerState.marker : asciiDigit(code)) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind;\n        effects.enter(kind, {\n          _container: true\n        });\n      }\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix');\n        return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix');\n        effects.enter('listItemValue');\n        return inside(code);\n      }\n    }\n    return nok(code);\n  }\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code);\n      return inside;\n    }\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\n      effects.exit('listItemValue');\n      return atMarker(code);\n    }\n    return nok(code);\n  }\n  function atMarker(code) {\n    effects.enter('listItemMarker');\n    effects.consume(code);\n    effects.exit('listItemMarker');\n    self.containerState.marker = self.containerState.marker || code;\n    return effects.check(partialBlankLine,\n    // Can’t be empty when interrupting.\n    self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\n  }\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace');\n      effects.consume(code);\n      effects.exit('listItemPrefixWhitespace');\n      return endOfPrefix;\n    }\n    return nok(code);\n  }\n  function endOfPrefix(code) {\n    self.containerState.size = initialSize + sizeChunks(self.sliceStream(effects.exit('listItemPrefix')));\n    return ok(code);\n  }\n}\nfunction tokenizeListContinuation(effects, ok, nok) {\n  var self = this;\n  self.containerState._closeFlow = undefined;\n  return effects.check(partialBlankLine, onBlank, notBlank);\n  function onBlank(code) {\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine; // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return factorySpace(effects, ok, 'listItemIndent', self.containerState.size + 1)(code);\n  }\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined;\n      return notInCurrentItem(code);\n    }\n    self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined;\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\n  }\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true; // As we’re closing flow, we’re no longer interrupting.\n\n    self.interrupt = undefined;\n    return factorySpace(effects, effects.attempt(list, ok, nok), 'linePrefix', self.parser.constructs.disable.null.indexOf('codeIndented') > -1 ? undefined : 4)(code);\n  }\n}\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this;\n  return factorySpace(effects, afterPrefix, 'listItemIndent', self.containerState.size + 1);\n  function afterPrefix(code) {\n    return prefixSize(self.events, 'listItemIndent') === self.containerState.size ? ok(code) : nok(code);\n  }\n}\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type);\n}\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  var self = this;\n  return factorySpace(effects, afterPrefix, 'listItemPrefixWhitespace', self.parser.constructs.disable.null.indexOf('codeIndented') > -1 ? undefined : 4 + 1);\n  function afterPrefix(code) {\n    return markdownSpace(code) || !prefixSize(self.events, 'listItemPrefixWhitespace') ? nok(code) : ok(code);\n  }\n}\nmodule.exports = list;","map":null,"metadata":{},"sourceType":"script"}