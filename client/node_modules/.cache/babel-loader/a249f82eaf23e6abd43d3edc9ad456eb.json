{"ast":null,"code":"var PUBLISH = 0;\nvar SUBSCRIBE = 1;\nvar RESET = 2;\nvar VALUE = 4;\n\n/**\r\n * Utils includes\r\n * - a handful of functional utilities inspired by or taken from the [Ramda library](https://ramdajs.com/);\r\n * - TypeScript crutches - the [[tup]] function.\r\n *\r\n * Use these for your convenience - they are here so that urx is zero-dependency package.\r\n *\r\n * @packageDocumentation\r\n */\n\n/**\r\n * Performs left to right composition of two functions.\r\n */\nfunction compose(a, b) {\n  return function (arg) {\n    return a(b(arg));\n  };\n}\n/**\r\n * Takes a value and applies a function to it.\r\n */\n\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\n/**\r\n * Takes a 2 argument function and partially applies the first argument.\r\n */\n\nfunction curry2to1(proc, arg1) {\n  return function (arg2) {\n    return proc(arg1, arg2);\n  };\n}\n/**\r\n * Takes a 1 argument function and returns a function which when called, executes it with the provided argument.\r\n */\n\nfunction curry1to0(proc, arg) {\n  return function () {\n    return proc(arg);\n  };\n}\n/**\r\n * Returns a function which extracts the property from from the passed object.\r\n */\n\nfunction prop(property) {\n  return function (object) {\n    return object[property];\n  };\n}\n/**\r\n * Calls callback with the first argument, and returns it.\r\n */\n\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\n/**\r\n *  Utility function to help typescript figure out that what we pass is a tuple and not a generic array.\r\n *  Taken from (this StackOverflow tread)[https://stackoverflow.com/questions/49729550/implicitly-create-a-tuple-in-typescript/52445008#52445008]\r\n */\n\nfunction tup() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return args;\n}\n/**\r\n * Calls the passed function.\r\n */\n\nfunction call(proc) {\n  proc();\n}\n/**\r\n * returns a function which when called always returns the passed value\r\n */\n\nfunction always(value) {\n  return function () {\n    return value;\n  };\n}\n/**\r\n * returns a function which calls all passed functions in the passed order.\r\n * joinProc does not pass arguments or collect return values.\r\n */\n\nfunction joinProc() {\n  for (var _len2 = arguments.length, procs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    procs[_key2] = arguments[_key2];\n  }\n  return function () {\n    procs.map(call);\n  };\n}\nfunction noop() {}\n\n/**\r\n * urx Actions operate on streams - `publish` publishes data in a stream, and `subscribe` attaches a subscription to a stream.\r\n * @packageDocumentation\r\n */\n/**\r\n * Subscribes the specified [[Subscription]] to the updates from the Emitter.\r\n * The emitter calls the subscription with the new data each time new data is published into it.\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n * subscribe(foo, (value) => console.log(value));\r\n * ```\r\n *\r\n * @returns an [[Unsubscribe]] handle  - calling it will unbind the subscription from the emitter.\r\n *```ts\r\n * const foo = stream<number>();\r\n * const unsub = subscribe(foo, (value) => console.log(value));\r\n * unsub();\r\n *```\r\n */\n\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\n/**\r\n * Publishes the value into the passed [[Publisher]].\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n * publish(foo, 42);\r\n * ```\r\n */\n\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\n/**\r\n * Clears all subscriptions from the [[Emitter]].\r\n * ```ts\r\n * const foo = stream<number>();\r\n * subscribe(foo, (value) => console.log(value));\r\n * reset(foo);\r\n * publish(foo, 42);\r\n * ```\r\n */\n\nfunction reset(emitter) {\n  emitter(RESET);\n}\n/**\r\n * Extracts the current value from a stateful stream. Use it only as an escape hatch, as it violates the concept of reactive programming.\r\n * ```ts\r\n * const foo = statefulStream(42);\r\n * console.log(getValue(foo));\r\n * ```\r\n */\n\nfunction getValue(depot) {\n  return depot(VALUE);\n}\n/**\r\n * Connects two streams - any value emitted from the emitter will be published in the publisher.\r\n * ```ts\r\n * const foo = stream<number>();\r\n * const bar = stream<number>();\r\n * subscribe(bar, (value) => console.log(`Bar emitted ${value}`));\r\n *\r\n * connect(foo, bar);\r\n * publish(foo);\r\n * ```\r\n * @returns an [[Unsubscribe]] handle which will disconnect the two streams.\r\n */\n\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\n/**\r\n * Executes the passed subscription at most once, for the next emit from the emitter.\r\n * ```ts\r\n * const foo = stream<number>()\r\n * handleNext(foo, value => console.log(value)) // called once, with 42\r\n * publish(foo, 42)\r\n * publish(foo, 43)\r\n * ```\r\n * @returns an [[Unsubscribe]] handle to unbind the subscription if necessary.\r\n */\n\nfunction handleNext(emitter, subscription) {\n  var unsub = emitter(SUBSCRIBE, function (value) {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\n\n/**\r\n * Streams are the basic building blocks of a reactive system. Think of them as the system permanent \"data tubes\".\r\n *\r\n * A stream acts as both an [[Emitter]] and [[Publisher]]. Each stream can have multiple {@link Subscription | Subscriptions}.\r\n *\r\n * urx streams are either **stateless** or **stateful**.\r\n * Stateless streams emit data to existing subscriptions when published, without keeping track of it.\r\n * Stateful streams remember the last published value and immediately publish it to new subscriptions.\r\n *\r\n * ```ts\r\n * import { stream, statefulStream, publish, subscribe } from \"@virtuoso.dev/urx\";\r\n *\r\n * // foo is a stateless stream\r\n * const foo = stream<number>();\r\n *\r\n * publish(foo, 42);\r\n * // this subsription will not be called...\r\n * subscribe(foo, (value) => console.log(value));\r\n * // it will only catch published values after it\r\n * publish(foo, 43);\r\n *\r\n * // stateful streams always start with an initial value\r\n * const bar = statefulStream(42);\r\n *\r\n * // subscribing to a stateful stream\r\n * // immediately calls the subscription with the current value\r\n * subscribe(bar, (value) => console.log(value));\r\n *\r\n * // subsequent publishing works just like stateless streams\r\n * publish(bar, 43);\r\n * ```\r\n * @packageDocumentation\r\n */\n/**\r\n * Constructs a new stateless stream.\r\n * ```ts\r\n * const foo = stream<number>();\r\n * ```\r\n * @typeParam T the type of values to publish in the stream.\r\n * @returns a [[Stream]]\r\n */\n\nfunction stream() {\n  var subscriptions = [];\n  return function (action, arg) {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return function () {\n          var indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach(function (subscription) {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n/**\r\n * Constructs a new stateful stream.\r\n * ```ts\r\n * const foo = statefulStream(42);\r\n * ```\r\n * @param initial the initial value in the stream.\r\n * @typeParam T the type of values to publish in the stream. If omitted, the function infers it from the initial value.\r\n * @returns a [[StatefulStream]]\r\n */\n\nfunction statefulStream(initial) {\n  var value = initial;\n  var innerSubject = stream();\n  return function (action, arg) {\n    switch (action) {\n      case SUBSCRIBE:\n        var subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\n/**\r\n * Event handlers are special emitters which can have **at most one active subscription**.\r\n * Subscribing to an event handler unsubscribes the previous subscription, if present.\r\n * ```ts\r\n * const foo = stream<number>();\r\n * const fooEvent = eventHandler(foo);\r\n *\r\n * // will be called once with 42\r\n * subscribe(fooEvent, (value) => console.log(`Sub 1 ${value}`));\r\n * publish(foo, 42);\r\n *\r\n * // unsubscribes sub 1\r\n * subscribe(fooEvent, (value) => console.log(`Sub 2 ${value}`));\r\n * publish(foo, 43);\r\n * ```\r\n * @param emitter the source emitter.\r\n * @returns the single-subscription emitter.\r\n */\n\nfunction eventHandler(emitter) {\n  var unsub;\n  var currentSubscription;\n  var cleanup = function cleanup() {\n    return unsub && unsub();\n  };\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n/**\r\n * Creates and connects a \"junction\" stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n *\r\n * const fooX2 = pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * );\r\n *\r\n * subscribe(fooX2, (value) => console.log(value));\r\n * subscribe(fooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42); // executes the map operator twice for each subscription.\r\n *\r\n * const sharedFooX2 = streamFromEmitter(pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`shared multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * ));\r\n *\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42);\r\n *```\r\n * @returns the resulting stream.\r\n */\n\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), function (stream) {\n    return connect(emitter, stream);\n  });\n}\n/**\r\n * Creates and connects a \"junction\" stateful stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\r\n *\r\n * ```ts\r\n * const foo = stream<number>();\r\n *\r\n * const fooX2 = pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * );\r\n *\r\n * subscribe(fooX2, (value) => console.log(value));\r\n * subscribe(fooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42); // executes the map operator twice for each subscription.\r\n *\r\n * const sharedFooX2 = statefulStreamFromEmitter(pipe(\r\n *   foo,\r\n *   map((value) => {\r\n *     console.log(`shared multiplying ${value}`);\r\n *     return value * 2;\r\n *   })\r\n * ), 42);\r\n *\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n * subscribe(sharedFooX2, (value) => console.log(value));\r\n *\r\n * publish(foo, 42);\r\n *```\r\n * @param initial the initial value in the stream.\r\n * @returns the resulting stateful stream.\r\n */\n\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), function (stream) {\n    return connect(emitter, stream);\n  });\n}\n\n/**\r\n *\r\n * Stream values can be transformed and controlled by {@link pipe | **piping**} through **operators**.\r\n * urx includes several operators like [[map]], [[filter]], [[scan]], and [[throttleTime]].\r\n * The [[withLatestFrom]] operator allows the combination of values from other streams.\r\n *\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * // create an emitter that first adds 2 to the passed value, then multiplies it by * 2\r\n * const bar = pipe(foo, map(value => value + 2), map(value => value * 2))\r\n * subscribe(bar, value => console.log(value))\r\n * publish(foo, 2) // outputs 8\r\n * ```\r\n *\r\n * ### Implementing Custom Operators\r\n * To implement your own operators, implement the [[Operator]] interface.\r\n * @packageDocumentation\r\n */\n/** @internal */\n\nfunction combineOperators() {\n  for (var _len = arguments.length, operators = new Array(_len), _key = 0; _key < _len; _key++) {\n    operators[_key] = arguments[_key];\n  }\n  return function (subscriber) {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source) {\n  for (var _len2 = arguments.length, operators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    operators[_key2 - 1] = arguments[_key2];\n  }\n\n  // prettier-ignore\n  var project = combineOperators.apply(void 0, operators);\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n/**\r\n * The default [[Comparator]] for [[distinctUntilChanged]] and [[duc]].\r\n */\n\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\n/**\r\n * Filters out identical values. Pass an optional [[Comparator]] if you need to filter non-primitive values.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, distinctUntilChanged()),\r\n *  console.log\r\n * ) // will be called only once\r\n *\r\n * publish(foo, 42)\r\n * publish(foo, 42)\r\n * ```\r\n */\n\nfunction distinctUntilChanged(comparator) {\n  if (comparator === void 0) {\n    comparator = defaultComparator;\n  }\n  var current;\n  return function (done) {\n    return function (next) {\n      if (!comparator(current, next)) {\n        current = next;\n        done(next);\n      }\n    };\n  };\n}\n/**\r\n * Filters out values for which the predicator does not return `true`-ish.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, filter(value => value % 2 === 0)),\r\n *  console.log\r\n * ) // will be called only with even values\r\n *\r\n * publish(foo, 2)\r\n * publish(foo, 3)\r\n * publish(foo, 4)\r\n * publish(foo, 5)\r\n * ```\r\n */\n\nfunction filter(predicate) {\n  return function (done) {\n    return function (value) {\n      predicate(value) && done(value);\n    };\n  };\n}\n/**\r\n * Maps values using the provided project function.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, map(value => value * 2)),\r\n *  console.log\r\n * ) // 4, 6\r\n *\r\n * publish(foo, 2)\r\n * publish(foo, 3)\r\n * ```\r\n */\n\nfunction map(project) {\n  return function (done) {\n    return compose(done, project);\n  };\n}\n/**\r\n * Maps values to the hard-coded value.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, mapTo(3)),\r\n *  console.log\r\n * ) // 3, 3\r\n *\r\n * publish(foo, 1)\r\n * publish(foo, 2)\r\n * ```\r\n */\n\nfunction mapTo(value) {\n  return function (done) {\n    return function () {\n      return done(value);\n    };\n  };\n}\n/**\r\n * Works like Array#reduce.\r\n * Applies an accumulator function on the emitter, and outputs intermediate result. Starts with the initial value.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, scan((acc, value) => acc + value, 2),\r\n *  console.log\r\n * ) // 3, 5\r\n *\r\n * publish(foo, 1)\r\n * publish(foo, 2)\r\n * ```\r\n */\n\nfunction scan(scanner, initial) {\n  return function (done) {\n    return function (value) {\n      return done(initial = scanner(initial, value));\n    };\n  };\n}\n/**\r\n * Skips the specified amount of values from the emitter.\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * subscribe(\r\n *  pipe(foo, skip(2)),\r\n *  console.log\r\n * ) // 3, 4\r\n *\r\n * publish(foo, 1) // skipped\r\n * publish(foo, 2) // skipped\r\n * publish(foo, 3)\r\n * publish(foo, 4)\r\n * ```\r\n */\n\nfunction skip(times) {\n  return function (done) {\n    return function (value) {\n      times > 0 ? times-- : done(value);\n    };\n  };\n}\n/**\r\n * Throttles flowing values at the provided interval in milliseconds.\r\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\r\n *\r\n * ```ts\r\n *  const foo = stream<number>()\r\n *  publish(foo, 1)\r\n *\r\n *  setTimeout(() => publish(foo, 2), 20)\r\n *  setTimeout(() => publish(foo, 3), 20)\r\n *\r\n *  subscribe(pipe(foo, throttleTime(50)), val => {\r\n *    console.log(value); // 3\r\n *  })\r\n * ```\r\n */\n\nfunction throttleTime(interval) {\n  var currentValue;\n  var timeout;\n  return function (done) {\n    return function (value) {\n      currentValue = value;\n      if (timeout) {\n        return;\n      }\n      timeout = setTimeout(function () {\n        timeout = undefined;\n        done(currentValue);\n      }, interval);\n    };\n  };\n}\n/**\r\n * Debounces flowing values at the provided interval in milliseconds.\r\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\r\n *\r\n * ```ts\r\n *  const foo = stream<number>()\r\n *  publish(foo, 1)\r\n *\r\n *  setTimeout(() => publish(foo, 2), 20)\r\n *  setTimeout(() => publish(foo, 3), 20)\r\n *\r\n *  subscribe(pipe(foo, debounceTime(50)), val => {\r\n *    console.log(value); // 3\r\n *  })\r\n * ```\r\n */\n\nfunction debounceTime(interval) {\n  var currentValue;\n  var timeout;\n  return function (done) {\n    return function (value) {\n      currentValue = value;\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n      timeout = setTimeout(function () {\n        done(currentValue);\n      }, interval);\n    };\n  };\n}\nfunction withLatestFrom() {\n  for (var _len3 = arguments.length, sources = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    sources[_key3] = arguments[_key3];\n  }\n  var values = new Array(sources.length);\n  var called = 0;\n  var pendingCall = null;\n  var allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach(function (source, index) {\n    var bit = Math.pow(2, index);\n    subscribe(source, function (value) {\n      var prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return function (done) {\n    return function (value) {\n      var call = function call() {\n        return done([value].concat(values));\n      };\n      if (called === allCalled) {\n        call();\n      } else {\n        pendingCall = call;\n      }\n    };\n  };\n}\n\n/**\r\n * Transformers change and combine streams, similar to operators.\r\n * urx comes with two combinators - [[combineLatest]] and [[merge]], and one convenience filter - [[duc]].\r\n *\r\n * @packageDocumentation\r\n */\n/**\r\n * Merges one or more emitters from the same type into a new Emitter which emits values from any of the source emitters.\r\n * ```ts\r\n * const foo = stream<number>()\r\n * const bar = stream<number>()\r\n *\r\n * subscribe(merge(foo, bar), (value) => console.log(value)) // 42, 43\r\n *\r\n * publish(foo, 42)\r\n * publish(bar, 43)\r\n * ```\r\n */\n\nfunction merge() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc.apply(void 0, sources.map(function (source) {\n          return subscribe(source, subscription);\n        }));\n      case RESET:\n        // do nothing, we are stateless\n        return;\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n/**\r\n * A convenience wrapper that emits only the distinct values from the passed Emitter. Wraps [[pipe]] and [[distinctUntilChanged]].\r\n *\r\n * ```ts\r\n * const foo = stream<number>()\r\n *\r\n * // this line...\r\n * const a = duc(foo)\r\n *\r\n * // is equivalent to this\r\n * const b = pipe(distinctUntilChanged(foo))\r\n * ```\r\n *\r\n * @param source The source emitter.\r\n * @param comparator optional custom comparison function for the two values.\r\n *\r\n * @typeParam T the type of the value emitted by the source.\r\n *\r\n * @returns the resulting emitter.\r\n */\n\nfunction duc(source, comparator) {\n  if (comparator === void 0) {\n    comparator = defaultComparator;\n  }\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest() {\n  var innerSubject = stream();\n  for (var _len2 = arguments.length, emitters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    emitters[_key2] = arguments[_key2];\n  }\n  var values = new Array(emitters.length);\n  var called = 0;\n  var allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach(function (source, index) {\n    var bit = Math.pow(2, index);\n    subscribe(source, function (value) {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(\"unrecognized action \" + action);\n    }\n  };\n}\n\n/**\r\n * `system` defines a specification of a system - its constructor, dependencies and if it should act as a singleton in a system dependency tree.\r\n * When called, system returns a [[SystemSpec]], which is then initialized along with its dependencies by passing it to [[init]].\r\n *\r\n * ```ts\r\n * @import { subscribe, publish, system, init, tup, connect, map, pipe } from 'urx'\r\n *\r\n * // a simple system with two streams\r\n * const sys1 = system(() => {\r\n *  const a = stream<number>()\r\n *  const b = stream<number>()\r\n *\r\n *  connect(pipe(a, map(value => value * 2)), b)\r\n *  return { a, b }\r\n * })\r\n *\r\n * // a second system which depends on the streams from the first one\r\n * const sys2 = system(([ {a, b} ]) => {\r\n *  const c = stream<number>()\r\n *  connect(pipe(b, map(value => value * 2)), c)\r\n *  // re-export the `a` stream, keep `b` internal\r\n *  return { a, c }\r\n * }, tup(sys1))\r\n *\r\n * // init will recursively initialize sys2 dependencies, in this case sys1\r\n * const { a, c } = init(sys2)\r\n * subscribe(c, c => console.log(`Value multiplied by 4`, c))\r\n * publish(a, 2)\r\n * ```\r\n *\r\n * #### Singletons in Dependency Tree\r\n *\r\n * By default, systems will be initialized only once if encountered multiple times in the dependency tree.\r\n * In the below dependency system tree, systems `b` and `c` will receive the same stream instances from system `a` when system `d` is initialized.\r\n * ```txt\r\n *   a\r\n *  / \\\r\n * b   c\r\n *  \\ /\r\n *   d\r\n * ```\r\n * If `a` gets `{singleton: false}` as a last argument, `init` creates two separate instances - one for `b` and one for `c`.\r\n *\r\n * @param constructor the system constructor function. Initialize and connect the streams in its body.\r\n *\r\n * @param dependencies the system dependencies, which the constructor will receive as arguments.\r\n * Use the [[tup]] utility **For TypeScript type inference to work correctly**.\r\n * ```ts\r\n * const sys3 = system(() => { ... }, tup(sys2, sys1))\r\n * ```\r\n * @param __namedParameters Options\r\n * @param singleton determines if the system will act as a singleton in a system dependency tree. `true` by default.\r\n */\nfunction system(constructor, dependencies, _temp) {\n  if (dependencies === void 0) {\n    dependencies = [];\n  }\n  var _ref = _temp === void 0 ? {\n      singleton: true\n    } : _temp,\n    singleton = _ref.singleton;\n  return {\n    id: id(),\n    constructor: constructor,\n    dependencies: dependencies,\n    singleton: singleton\n  };\n}\n/** @internal */\n\nvar id = function id() {\n  return Symbol();\n};\n/**\r\n * Initializes a [[SystemSpec]] by recursively initializing its dependencies.\r\n *\r\n * ```ts\r\n * // a simple system with two streams\r\n * const sys1 = system(() => {\r\n *  const a = stream<number>()\r\n *  const b = stream<number>()\r\n *\r\n *  connect(pipe(a, map(value => value * 2)), b)\r\n *  return { a, b }\r\n * })\r\n *\r\n * const { a, b } = init(sys1)\r\n * subscribe(b, b => console.log(b))\r\n * publish(a, 2)\r\n * ```\r\n *\r\n * @returns the [[System]] constructed by the spec constructor.\r\n * @param systemSpec the system spec to initialize.\r\n */\n\nfunction init(systemSpec) {\n  var singletons = new Map();\n  var _init = function _init(_ref2) {\n    var id = _ref2.id,\n      constructor = _ref2.constructor,\n      dependencies = _ref2.dependencies,\n      singleton = _ref2.singleton;\n    if (singleton && singletons.has(id)) {\n      return singletons.get(id);\n    }\n    var system = constructor(dependencies.map(function (e) {\n      return _init(e);\n    }));\n    if (singleton) {\n      singletons.set(id, system);\n    }\n    return system;\n  };\n  return _init(systemSpec);\n}\nexport { always, call, combineLatest, compose, connect, curry1to0, curry2to1, debounceTime, defaultComparator, distinctUntilChanged, duc, eventHandler, filter, getValue, handleNext, init, joinProc, map, mapTo, merge, noop, pipe, prop, publish, reset, scan, skip, statefulStream, statefulStreamFromEmitter, stream, streamFromEmitter, subscribe, system, tap, throttleTime, thrush, tup, withLatestFrom };","map":null,"metadata":{},"sourceType":"module"}