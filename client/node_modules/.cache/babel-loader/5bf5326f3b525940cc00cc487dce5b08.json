{"ast":null,"code":"import _objectSpread from \"/Users/ebubechi/Desktop/UniVerse/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\n/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  var indexStack = state.indexStack;\n  var children = parent.children || [];\n  /** @type {Array<string>} */\n  var results = [];\n  var index = -1;\n  var before = info.before;\n  indexStack.push(-1);\n  var tracker = state.createTracker(info);\n  while (++index < children.length) {\n    var child = children[index];\n    /** @type {string} */\n    var after = void 0;\n    indexStack[indexStack.length - 1] = index;\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      var handle = state.handle.handlers[children[index + 1].type];\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek;\n      after = handle ? handle(children[index + 1], parent, state, _objectSpread({\n        before: '',\n        after: ''\n      }, tracker.current())).charAt(0) : '';\n    } else {\n      after = info.after;\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (results.length > 0 && (before === '\\r' || before === '\\n') && child.type === 'html') {\n      results[results.length - 1] = results[results.length - 1].replace(/(\\r?\\n|\\r)$/, ' ');\n      before = ' ';\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info);\n      tracker.move(results.join(''));\n    }\n    results.push(tracker.move(state.handle(child, parent, state, _objectSpread({}, tracker.current(), {\n      before: before,\n      after: after\n    }))));\n    before = results[results.length - 1].slice(-1);\n  }\n  indexStack.pop();\n  return results.join('');\n}","map":null,"metadata":{},"sourceType":"module"}