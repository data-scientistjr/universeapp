{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport React from 'react';\nimport emojiRegex from 'emoji-regex';\nimport { find } from 'linkifyjs';\nimport { nanoid } from 'nanoid';\nimport { findAndReplace } from 'hast-util-find-and-replace';\nimport ReactMarkdown, { uriTransformer } from 'react-markdown';\nimport { u } from 'unist-builder';\nimport { visit } from 'unist-util-visit';\nimport remarkGfm from 'remark-gfm';\nimport uniqBy from 'lodash.uniqby';\nimport clsx from 'clsx';\nexport var isOnlyEmojis = function isOnlyEmojis(text) {\n  if (!text) return false;\n  var noEmojis = text.replace(emojiRegex(), '');\n  var noSpace = noEmojis.replace(/[\\s\\n]/gm, '');\n  return !noSpace;\n};\nvar allowedMarkups = ['html', 'text', 'br', 'p', 'em', 'strong', 'a', 'ol', 'ul', 'li', 'code', 'pre', 'blockquote', 'del',\n// custom types (tagNames)\n'emoji', 'mention'];\nexport var matchMarkdownLinks = function matchMarkdownLinks(message) {\n  var regexMdLinks = /\\[([^[]+)\\](\\(.*\\))/gm;\n  var matches = message.match(regexMdLinks);\n  var singleMatch = /\\[([^[]+)\\]\\((.*)\\)/;\n  var links = matches ? matches.map(function (match) {\n    var i = singleMatch.exec(match);\n    return i && [i[1], i[2]];\n  }) : [];\n  return links.flat();\n};\nexport var messageCodeBlocks = function messageCodeBlocks(message) {\n  var codeRegex = /```[a-z]*\\n[\\s\\S]*?\\n```|`[a-z]*[\\s\\S]*?`/gm;\n  var matches = message.match(codeRegex);\n  return matches || [];\n};\nvar detectHttp = /(http(s?):\\/\\/)?(www\\.)?/;\nfunction formatUrlForDisplay(url) {\n  try {\n    return decodeURIComponent(url).replace(detectHttp, '');\n  } catch (e) {\n    return url;\n  }\n}\nfunction encodeDecode(url) {\n  try {\n    return encodeURI(decodeURIComponent(url));\n  } catch (error) {\n    return url;\n  }\n}\nvar Anchor = function Anchor(_a) {\n  var children = _a.children,\n    href = _a.href;\n  var isEmail = href === null || href === void 0 ? void 0 : href.startsWith('mailto:');\n  var isUrl = href === null || href === void 0 ? void 0 : href.startsWith('http');\n  if (!href || !isEmail && !isUrl) return React.createElement(React.Fragment, null, children);\n  return React.createElement(\"a\", {\n    className: clsx({\n      'str-chat__message-url-link': isUrl\n    }),\n    href: href,\n    rel: 'nofollow noreferrer noopener',\n    target: '_blank'\n  }, children);\n};\nvar Emoji = function Emoji(_a) {\n  var children = _a.children;\n  return React.createElement(\"span\", {\n    className: 'inline-text-emoji',\n    \"data-testid\": 'inline-text-emoji'\n  }, children);\n};\nvar Mention = function Mention(_a) {\n  var children = _a.children,\n    mentionedUser = _a.node.mentionedUser;\n  return React.createElement(\"span\", {\n    className: 'str-chat__message-mention',\n    \"data-user-id\": mentionedUser.id\n  }, children);\n};\nexport var markDownRenderers = {\n  a: Anchor,\n  emoji: Emoji,\n  mention: Mention\n};\nexport var emojiMarkdownPlugin = function emojiMarkdownPlugin() {\n  var replace = function replace(match) {\n    return u('element', {\n      tagName: 'emoji'\n    }, [u('text', match)]);\n  };\n  var transform = function transform(node) {\n    return findAndReplace(node, emojiRegex(), replace);\n  };\n  return transform;\n};\nexport var mentionsMarkdownPlugin = function mentionsMarkdownPlugin(mentioned_users) {\n  return function () {\n    var mentioned_usernames = mentioned_users.map(function (user) {\n      return user.name || user.id;\n    }).filter(Boolean).map(escapeRegExp);\n    var mentionedUsersRegex = new RegExp(mentioned_usernames.map(function (username) {\n      return \"@\".concat(username);\n    }).join('|'), 'g');\n    var replace = function replace(match) {\n      var usernameOrId = match.replace('@', '');\n      var user = mentioned_users.find(function (_a) {\n        var id = _a.id,\n          name = _a.name;\n        return name === usernameOrId || id === usernameOrId;\n      });\n      return u('element', {\n        mentionedUser: user,\n        tagName: 'mention'\n      }, [u('text', match)]);\n    };\n    var transform = function transform(tree) {\n      if (!mentioned_usernames.length) return tree;\n      // handles special cases of mentions where user.name is an e-mail\n      // Remark GFM translates all e-mail-like text nodes to links creating\n      // two separate child nodes \"@\" and \"your.name@as.email\" instead of\n      // keeping it as one text node with value \"@your.name@as.email\"\n      // this piece finds these two separated nodes and merges them together\n      // before \"replace\" function takes over\n      visit(tree, function (node, index, parent) {\n        var _a;\n        if (index === null) return;\n        if (!parent) return;\n        var nextChild = parent.children.at(index + 1);\n        var nextChildHref = (_a = nextChild === null || nextChild === void 0 ? void 0 : nextChild.properties) === null || _a === void 0 ? void 0 : _a.href;\n        if (node.type === 'text' &&\n        // text value has to have @ sign at the end of the string\n        // and no other characters except whitespace can precede it\n        // valid cases:   \"text @\", \"@\", \" @\"\n        // invalid cases: \"text@\", \"@text\",\n        /.?\\s?@$|^@$/.test(node.value) && (nextChildHref === null || nextChildHref === void 0 ? void 0 : nextChildHref.startsWith('mailto:'))) {\n          var newTextValue = node.value.replace(/@$/, '');\n          var username = nextChildHref.replace('mailto:', '');\n          parent.children[index] = u('text', newTextValue);\n          parent.children[index + 1] = u('text', \"@\".concat(username));\n        }\n      });\n      return findAndReplace(tree, mentionedUsersRegex, replace);\n    };\n    return transform;\n  };\n};\nexport var renderText = function renderText(text, mentionedUsers, _a) {\n  var _b = _a === void 0 ? {} : _a,\n    customMarkDownRenderers = _b.customMarkDownRenderers;\n  // take the @ mentions and turn them into markdown?\n  // translate links\n  if (!text) return null;\n  if (text.trim().length === 1) return React.createElement(React.Fragment, null, text);\n  var newText = text;\n  var markdownLinks = matchMarkdownLinks(newText);\n  var codeBlocks = messageCodeBlocks(newText);\n  // extract all valid links/emails within text and replace it with proper markup\n  uniqBy(__spreadArray(__spreadArray([], find(newText, 'email'), true), find(newText, 'url'), true), 'value').forEach(function (_a) {\n    var href = _a.href,\n      type = _a.type,\n      value = _a.value;\n    var linkIsInBlock = codeBlocks.some(function (block) {\n      return block === null || block === void 0 ? void 0 : block.includes(value);\n    });\n    // check if message is already  markdown\n    var noParsingNeeded = markdownLinks && markdownLinks.filter(function (text) {\n      var strippedHref = href === null || href === void 0 ? void 0 : href.replace(detectHttp, '');\n      var strippedText = text === null || text === void 0 ? void 0 : text.replace(detectHttp, '');\n      if (!strippedHref || !strippedText) return false;\n      return strippedHref.includes(strippedText) || strippedText.includes(strippedHref);\n    });\n    if (noParsingNeeded.length > 0 || linkIsInBlock) return;\n    try {\n      // special case for mentions:\n      // it could happen that a user's name matches with an e-mail format pattern.\n      // in that case, we check whether the found e-mail is actually a mention\n      // by naively checking for an existence of @ sign in front of it.\n      if (type === 'email' && mentionedUsers) {\n        var emailMatchesWithName = mentionedUsers.some(function (u) {\n          return u.name === value;\n        });\n        if (emailMatchesWithName) {\n          newText = newText.replace(new RegExp(escapeRegExp(value), 'g'), function (match, position) {\n            var isMention = newText.charAt(position - 1) === '@';\n            // in case of mention, we leave the match in its original form,\n            // and we let `mentionsMarkdownPlugin` to do its job\n            return isMention ? match : \"[\".concat(match, \"](\").concat(encodeDecode(href), \")\");\n          });\n          return;\n        }\n      }\n      var displayLink = type === 'email' ? value : formatUrlForDisplay(href);\n      newText = newText.replace(new RegExp(escapeRegExp(value), 'g'), \"[\".concat(displayLink, \"](\").concat(encodeDecode(href), \")\"));\n    } catch (e) {\n      void e;\n    }\n  });\n  var rehypePlugins = [emojiMarkdownPlugin];\n  if (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) {\n    rehypePlugins.push(mentionsMarkdownPlugin(mentionedUsers));\n  }\n  // TODO: remove in the next major release\n  if (customMarkDownRenderers === null || customMarkDownRenderers === void 0 ? void 0 : customMarkDownRenderers.mention) {\n    var MentionComponent_1 = customMarkDownRenderers['mention'];\n    // eslint-disable-next-line react/display-name\n    customMarkDownRenderers['mention'] = function (_a) {\n      var node = _a.node,\n        rest = __rest(_a, [\"node\"]);\n      return React.createElement(MentionComponent_1\n      // @ts-ignore\n      , __assign({\n        // @ts-ignore\n        mentioned_user: node.mentionedUser,\n        // @ts-ignore\n        node: __assign({\n          mentioned_user: node.mentionedUser\n        }, node)\n      }, rest));\n    };\n  }\n  var rehypeComponents = __assign(__assign({}, markDownRenderers), customMarkDownRenderers);\n  return React.createElement(ReactMarkdown, {\n    allowedElements: allowedMarkups,\n    components: rehypeComponents,\n    rehypePlugins: rehypePlugins,\n    remarkPlugins: [[remarkGfm, {\n      singleTilde: false\n    }]],\n    skipHtml: true,\n    transformLinkUri: function transformLinkUri(uri) {\n      return uri.startsWith('app://') ? uri : uriTransformer(uri);\n    },\n    unwrapDisallowed: true\n  }, newText);\n};\nexport function escapeRegExp(text) {\n  return text.replace(/[-[\\]{}()*+?.,/\\\\^$|#]/g, '\\\\$&');\n}\n/**\n * @deprecated will be removed in the next major release\n */\nexport var generateRandomId = nanoid;\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt#getting_whole_characters\nexport var getWholeChar = function getWholeChar(str, i) {\n  var code = str.charCodeAt(i);\n  if (Number.isNaN(code)) return '';\n  if (code < 0xd800 || code > 0xdfff) return str.charAt(i);\n  if (0xd800 <= code && code <= 0xdbff) {\n    if (str.length <= i + 1) {\n      throw 'High surrogate without following low surrogate';\n    }\n    var next = str.charCodeAt(i + 1);\n    if (0xdc00 > next || next > 0xdfff) {\n      throw 'High surrogate without following low surrogate';\n    }\n    return str.charAt(i) + str.charAt(i + 1);\n  }\n  if (i === 0) {\n    throw 'Low surrogate without preceding high surrogate';\n  }\n  var prev = str.charCodeAt(i - 1);\n  if (0xd800 > prev || prev > 0xdbff) {\n    throw 'Low surrogate without preceding high surrogate';\n  }\n  return '';\n};","map":null,"metadata":{},"sourceType":"module"}