{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport React, { useContext } from 'react';\nexport var MessageContext = React.createContext(undefined);\nexport var MessageProvider = function MessageProvider(_a) {\n  var children = _a.children,\n    value = _a.value;\n  return React.createElement(MessageContext.Provider, {\n    value: value\n  }, children);\n};\nexport var useMessageContext = function useMessageContext(componentName) {\n  var contextValue = useContext(MessageContext);\n  if (!contextValue) {\n    console.warn(\"The useMessageContext hook was called outside of the MessageContext provider. Make sure this hook is called within the Message's UI component. The errored call is located in the \".concat(componentName, \" component.\"));\n    return {};\n  }\n  return contextValue;\n};\n/**\n * Typescript currently does not support partial inference, so if MessageContext\n * typing is desired while using the HOC withMessageContext, the Props for the\n * wrapped component must be provided as the first generic.\n */\nexport var withMessageContext = function withMessageContext(Component) {\n  var WithMessageContextComponent = function WithMessageContextComponent(props) {\n    var messageContext = useMessageContext();\n    return React.createElement(Component, __assign({}, props, messageContext));\n  };\n  WithMessageContextComponent.displayName = (Component.displayName || Component.name || 'Component').replace('Base', '');\n  return WithMessageContextComponent;\n};","map":null,"metadata":{},"sourceType":"module"}